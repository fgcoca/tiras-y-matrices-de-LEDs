<!doctype html><html lang=es class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Repositorio con web dedicado a dar unas notas sobre algunos de estos elementos. El tema será tratado tanto desde el entorno gráfico de ArduinoBlocks como desde el IDE de Arduino."><meta name=author content="Federico Coca"><link href=https://fgcoca.github.io/tiras-y-matrices-de-LEDs/temas/matriz8x32/ rel=canonical><link rel=icon href=../../img/favicon.png><meta name=generator content="mkdocs-1.4.2, mkdocs-material-8.5.10"><title>Matriz WS2812 8x32 - Tiras y matrices de LEDs</title><link rel=stylesheet href=../../assets/stylesheets/main.975780f9.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.2505c338.min.css><meta name=theme-color content=#02a6f2><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=light-blue data-md-color-accent=deep-purple> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#matriz-o-panel-de-8x32 class=md-skip> Saltar a contenido </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Cabecera> <a href=../.. title="Tiras y matrices de LEDs" class="md-header__button md-logo" aria-label="Tiras y matrices de LEDs" data-md-component=logo> <img src=../../img/favicon.png alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Tiras y matrices de LEDs </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Matriz WS2812 8x32 </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Búsqueda placeholder=Búsqueda autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Limpiar aria-label=Limpiar tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Inicializando búsqueda </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/fgcoca/tiras-y-matrices-de-LEDs title="Ir al repositorio" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> fgcoca/tiras-y-matrices-de-LEDs </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navegación data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="Tiras y matrices de LEDs" class="md-nav__button md-logo" aria-label="Tiras y matrices de LEDs" data-md-component=logo> <img src=../../img/favicon.png alt=logo> </a> Tiras y matrices de LEDs </label> <div class=md-nav__source> <a href=https://github.com/fgcoca/tiras-y-matrices-de-LEDs title="Ir al repositorio" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> fgcoca/tiras-y-matrices-de-LEDs </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> Introducción </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2> Software <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Software data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Software </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../softAB/ class=md-nav__link> ArduinoBlocks </a> </li> <li class=md-nav__item> <a href=../softIDE/ class=md-nav__link> IDE 2 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../alimentar/ class=md-nav__link> Alimentación </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4> Programación <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Programación data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Programación </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Matriz WS2812 8x32 <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Matriz WS2812 8x32 </a> <nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Tabla de contenidos </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#descripcion class=md-nav__link> Descripción </a> </li> <li class=md-nav__item> <a href=#programacion-con-arduinoblocks class=md-nav__link> Programación con ArduinoBlocks </a> <nav class=md-nav aria-label="Programación con ArduinoBlocks"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#bloques class=md-nav__link> Bloques </a> </li> <li class=md-nav__item> <a href=#ejemplos-de-uso class=md-nav__link> Ejemplos de uso </a> </li> <li class=md-nav__item> <a href=#trabajo-con-la-herramienta-neopixel-matrix-data class=md-nav__link> Trabajo con la herramienta Neopixel - Matrix data </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#librerias class=md-nav__link> Librerías </a> <nav class=md-nav aria-label=Librerías> <ul class=md-nav__list> <li class=md-nav__item> <a href=#libreria-gfx class=md-nav__link> Librería GFX </a> </li> <li class=md-nav__item> <a href=#libreria-neopixel class=md-nav__link> Librería NeoPixel </a> </li> <li class=md-nav__item> <a href=#libreria-neomatrix class=md-nav__link> Librería NeoMatrix </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#dibujos-basicos class=md-nav__link> Dibujos básicos </a> <nav class=md-nav aria-label="Dibujos básicos"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pixeles-y-cuadrados class=md-nav__link> Pixeles y cuadrados </a> </li> <li class=md-nav__item> <a href=#lineas-y-circulos class=md-nav__link> Líneas y circulos </a> </li> <li class=md-nav__item> <a href=#textos class=md-nav__link> Textos </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#uso-de-memoria-ram class=md-nav__link> Uso de memoria RAM </a> </li> <li class=md-nav__item> <a href=#correccion-gamma class=md-nav__link> Corrección gamma </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../matriz16x16/ class=md-nav__link> Matriz WS2812 16x16 </a> </li> <li class=md-nav__item> <a href=../matriz8x8/ class=md-nav__link> Matriz WS2812 8x8 </a> </li> <li class=md-nav__item> <a href=../LED8x8/ class=md-nav__link> Matriz MAX7219 8x8 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_5 type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5> El juego de la serpiente <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="El juego de la serpiente" data-md-level=1> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> El juego de la serpiente </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../3d/ class=md-nav__link> 3D </a> </li> <li class=md-nav__item> <a href=../serpiente/ class=md-nav__link> Programa </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_6 type=checkbox id=__nav_6> <label class=md-nav__link for=__nav_6> Miscelanea <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Miscelanea data-md-level=1> <label class=md-nav__title for=__nav_6> <span class="md-nav__icon md-icon"></span> Miscelanea </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Miscelanea/about/ class=md-nav__link> Autor </a> </li> <li class=md-nav__item> <a href=../../Miscelanea/lic/ class=md-nav__link> Licencias </a> </li> <li class=md-nav__item> <a href=../../Miscelanea/webgrafia/ class=md-nav__link> Webgrafia/Bibliografía </a> </li> <li class=md-nav__item> <a href=../../Miscelanea/soft/ class=md-nav__link> Software utilizado </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Tabla de contenidos </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#descripcion class=md-nav__link> Descripción </a> </li> <li class=md-nav__item> <a href=#programacion-con-arduinoblocks class=md-nav__link> Programación con ArduinoBlocks </a> <nav class=md-nav aria-label="Programación con ArduinoBlocks"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#bloques class=md-nav__link> Bloques </a> </li> <li class=md-nav__item> <a href=#ejemplos-de-uso class=md-nav__link> Ejemplos de uso </a> </li> <li class=md-nav__item> <a href=#trabajo-con-la-herramienta-neopixel-matrix-data class=md-nav__link> Trabajo con la herramienta Neopixel - Matrix data </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#librerias class=md-nav__link> Librerías </a> <nav class=md-nav aria-label=Librerías> <ul class=md-nav__list> <li class=md-nav__item> <a href=#libreria-gfx class=md-nav__link> Librería GFX </a> </li> <li class=md-nav__item> <a href=#libreria-neopixel class=md-nav__link> Librería NeoPixel </a> </li> <li class=md-nav__item> <a href=#libreria-neomatrix class=md-nav__link> Librería NeoMatrix </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#dibujos-basicos class=md-nav__link> Dibujos básicos </a> <nav class=md-nav aria-label="Dibujos básicos"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pixeles-y-cuadrados class=md-nav__link> Pixeles y cuadrados </a> </li> <li class=md-nav__item> <a href=#lineas-y-circulos class=md-nav__link> Líneas y circulos </a> </li> <li class=md-nav__item> <a href=#textos class=md-nav__link> Textos </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#uso-de-memoria-ram class=md-nav__link> Uso de memoria RAM </a> </li> <li class=md-nav__item> <a href=#correccion-gamma class=md-nav__link> Corrección gamma </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=matriz-o-panel-de-8x32><font color=#8B008B>Matriz o panel de 8x32</font><a class=headerlink href=#matriz-o-panel-de-8x32 title="Permanent link">&para;</a></h1> <h2 id=descripcion><font color=#007575><strong>Descripción</strong></font><a class=headerlink href=#descripcion title="Permanent link">&para;</a></h2> <p>En realidad se trata de tiras de 256 LEDs dispuestos en forma de panel o matriz que tienen el aspecto de la figura siguiente:</p> <p><center></p> <p><img alt="Aspecto de una matriz de 8x32" src=../../img/matriz8x32/aspecto.png></p> <p><em>Aspecto de una matriz de 8x32</em></p> <p></center></p> <p>Podemos observar que este tipo de paneles son, hasta cierto punto, flexibles y que permiten utilizar el concepto de apilado o encadenado conectando la salida de uno a la entrada del otro. En principio la única limitación de conexionado va a estar en la capacidad de entregar la corriente que demande la configuración de paneles.</p> <p>Referente al tema de la alimentación hemos de tener presente que cada uno de los LEDs puede consumir hasta 60 mA (20 mA cada color) si combinamos los colores a máximo brillo para obtener un color blanco intenso, por lo que el consumo máximo puede ser de:</p> <p><center></p> <p><span class=arithmatex><span class=MathJax_Preview>I\_max = 8 \cdot32 \cdot 60 = 15.360\space mA</span><script type=math/tex>I\_max = 8 \cdot32  \cdot 60 = 15.360\space mA</script></span></p> <p></center></p> <p>Es decir, que en las condiciones indicadas un panel puede llegar a consumir por encima de 15A, lo que nos indica claramente que tampoco están diseñados para trabajar de esta forma.</p> <p>En condiciones de brillo por debajo de 100 y los LEDs cambiando su estado (por ejemplo en un letrero que se desplaza) un panel se puede alimentar desde el conector de entrada que tiene 3 pines: DIN, 5V y GND.</p> <p>Los LEDs WS2812 que se utilizan son de 4 pines que se distribuyen en cada LED como vemos en la figura siguiente:</p> <p><center></p> <p><img alt="Pines LED WS2812" src=../../img/matriz8x32/pinesLED.png></p> <p><em>Pines LED WS2812</em></p> <p></center></p> <p>El panel o matriz que vamos a utilizar conecta los LEDs como vemos en la figura siguiente:</p> <p><center></p> <p><img alt="Panel con conexión en linea" src=../../img/matriz8x32/conexLED.png></p> <p><em>Panel con conexión en linea</em></p> <p></center></p> <p>La parte posterior de este panel tiene el aspecto de la figura siguiente:</p> <p><center></p> <p><img alt="Parte posterior del panel" src=../../img/matriz8x32/posterior.png></p> <p><em>Parte posterior del panel</em></p> <p></center></p> <p>Aunque debemos tener presente que los LEDs se pueden conectar de cualquiera de las formas que vemos en la figura siguiente:</p> <p><center></p> <p><img alt="Conexiones en zig zag y en linea" src=../../img/matriz8x32/2conex.png></p> <p><em>Conexiones en zig zag y en linea</em></p> <p></center></p> <h2 id=programacion-con-arduinoblocks><font color=#007575><strong>Programación con ArduinoBlocks</strong></font><a class=headerlink href=#programacion-con-arduinoblocks title="Permanent link">&para;</a></h2> <h3 id=bloques><font color=#AA0000>Bloques</font><a class=headerlink href=#bloques title="Permanent link">&para;</a></h3> <p>En la figura siguiente vemos el menú bloques disponible en 'Visualización' en su entrada 'NeoPixel'. </p> <p><center></p> <p><img alt="Bloques LEDs RGB direccionables" src=../../img/matriz8x32/bloquesAB.png></p> <p><em>Bloques LEDs RGB direccionables</em></p> <p></center></p> <p>Ya hemos indicado que la disposición en forma de matriz no implica que el conexionado de los LEDs esté realizado de esa forma, sino que están conectados como si de una tira se tratase y por ello los bloques tipo matriz no van a servirnos de mucha ayuda en la programación de estos elementos, y por eso se han puesto difuminados.</p> <p>Para demostrar esto se anima al lector a analizar el posible resultado de un simple programa como el de la figura siguiente:</p> <p><center></p> <p><img alt="Ejemplo para demostrar que no se programa como matriz" src=../../img/matriz8x32/Ej_no_matriz.png></p> <p><em>Ejemplo para demostrar que no se programa como matriz</em></p> <p></center></p> <p>Si cargamos el programa <a href=../../programas/Ej_no_matriz.abp>Ej_no_matriz.abp</a> en nuestra placa y lo hacemos funcionar con el panel conectado podremos observar como su comportamiento nada tiene que ver con el esperado.</p> <h3 id=ejemplos-de-uso><font color=#AA0000>Ejemplos de uso</font><a class=headerlink href=#ejemplos-de-uso title="Permanent link">&para;</a></h3> <p>Vamos a ver una serie de ejemplos de uso del panel tratado como tira de LEDs direccionables para ver que así funciona perfectamente.</p> <ul> <li><strong>A1. Encender y apagar todos los LEDs</strong>. En esta primera actividad vamos a establecer un nivel de brillo lo suficientemente bajo (15) como para que cuando se enciendan todos los LEDs nuestro USB no se desconecte por exceso de consumo. Si queremos trabajar con brillos mayores basta con alimentar el panel a través de los cables destinados a ello con una fuente de alimentación adecuada, pero recordemos el consumo máximo que pueden llegar a tener si los ponemos todos a máximo brillo y en blanco, que supera los 15A. Por otro lado en el bucle de encendido hemos dado un pequeño retardo que demuestra claramente como están conectados los LEDs. En el enlace tenemos el programa <a href=../../programas/on_off.abp>A1. Encender y apagar todos los LEDs</a> siguiente:</li> </ul> <p><center></p> <p><img alt="A1. Encender y apagar todos los LEDs" src=../../img/matriz8x32/on_off.png></p> <p><em>A1. Encender y apagar todos los LEDs</em></p> <p></center></p> <ul> <li><strong>A2. Encender todos desplazando el LED encendido</strong>. Se trata del mismo bucle que en la actividad anterior pero en esta ocasión borramos los datos en cada iteración haciendo así que solamente se encienda un LED. En el enlace tenemos el programa <a href=../../programas/on_1en1.abp>A2. Encender todos desplazando el LED encendido</a> siguiente:</li> </ul> <p><center></p> <p><img alt="A2. Encender todos desplazando el LED encendido" src=../../img/matriz8x32/on_1en1.png></p> <p><em>A2. Encender todos desplazando el LED encendido</em></p> <p></center></p> <ul> <li><strong>A3. Encender pares e impares con color aleatorio</strong>. Con un bucle encendemos los LEDs de color par después de llamar a la función que establece de forma aleatoria los valores RGB, con otro hacemos lo mismo pero con los impares y finalmente con otro bucle los apagamos todos durante un tiempo. En el enlace tenemos el programa <a href=../../programas/par_impar.abp>A3. Encender pares e impares con color aleatorio</a> siguiente:</li> </ul> <p><center></p> <p><img alt="A3. Encender pares e impares con color aleatorio" src=../../img/matriz8x32/par_impar.png></p> <p><em>A3. Encender pares e impares con color aleatorio</em></p> <p></center></p> <hr> <p><font color=#ff00ff><font size=5><b>De esta forma podemos seguir haciendo cosas con el panel pero la verdad es que salvo la disposición de los LEDs no se ven muchas mas posibilidades</b></font></font></p> <hr> <h3 id=trabajo-con-la-herramienta-neopixel-matrix-data><font color=#AA0000><strong>Trabajo con la herramienta Neopixel - Matrix data</strong></font><a class=headerlink href=#trabajo-con-la-herramienta-neopixel-matrix-data title="Permanent link">&para;</a></h3> <p>Accedemos a ella a través el menú herramientas, tal y como vemos en la animación de la figura siguiente. Observamos como establecer el tipo de matriz según estén conexionados los LEDs en línea o zig zag y simplemente se han pintado algunos pixeles de diferentes colores a modo de ejemplo.</p> <p><center></p> <p><img alt="Herramienta Neopixel - Matrix data" src=../../img/matriz8x32/ej_matrix_data.gif></p> <p><em>Herramienta Neopixel - Matrix data</em></p> <p></center></p> <p><center></p> <p><img alt="Ejemplo de uso de la herramienta Neopixel - Matrix data" src=../../img/matriz8x32/ej_uso_matrix_data.png></p> <p><em>Ejemplo de uso de la herramienta Neopixel - Matrix data</em></p> <p></center></p> <p>Mostrar ese diseño en la matriz es tan sencillo como hacer un programa como el de la figura siguiente.</p> <p><center></p> <p><img alt="Ejemplo de uso de la herramienta Neopixel - Matrix data" src=../../img/matriz8x32/ej_uso_matrix_data.png></p> <p><em>Ejemplo de uso de la herramienta Neopixel - Matrix data</em></p> <p></center></p> <p>Hemos copiado los datos generados en el bloque 'Establecer datos'. Es posible realizar diseños mas complejos con esta herramienta, como por ejemplo escribir textos, pero nos vamos a encontrar que es un trabajo bastante complejo, lento y tedioso al que además se añade una dificultad, y es que el diseño en pantalla está en posición espejo (como si se reflejase en uno) respecto a la posición real de los diodos del panel del que dispongo. Un ejemplo, con algún pequeño error que no se ha corregido a propósito, como el que vemos en el vídeo siguiente ha costado algo mas de una hora llevarlo a cabo.Adafruit_NeoMatrix</p> <p><center></p> <iframe width=560 height=315 src=https://www.youtube.com/embed/mZbF2w7pb5Q title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> <p></center></p> <p>También existe una herramienta de generación de los datos a partir de una imagen, pero esta debe tener una resolución similar a la del panel para que obtengamos algo viable. En la imagen siguiente vemos el resultado obtenido a partir de la imagen original de la izquierda y vemos que se parecen en poco o nada.</p> <p><center></p> <p><img alt="Ejemplo de uso de la herramienta Neopixel - Matrix data" src=../../img/matriz8x32/ej_uso_matrix_data_archivo.png></p> <p><em>Ejemplo de uso de la herramienta Neopixel - Matrix data</em></p> <p></center></p> <hr> <p><font color=#aa55ff><font size=5><b>Aunque podemos crear efectos y alguna cosa mas parece evidente que hoy por hoy no se trabaja con eficiencia en ArduinoBlocks con este tipo de elementos. Vamos a ver a continuación como hacerlo de una mejor manera utilizando el IDE de Arduino y las librerías necesarias para su funcionamiento.</b></font></font></p> <hr> <h2 id=librerias><font color=#007575><strong>Librerías</strong></font><a class=headerlink href=#librerias title="Permanent link">&para;</a></h2> <p>Para un correcto funcionamiento vamos a necesitar las siguientes bibliotecas:</p> <ul> <li><a href=https://github.com/adafruit/Adafruit-GFX-Library><strong>Adafruit_GFX</strong></a></li> <li><a href=https://github.com/adafruit/Adafruit_NeoMatrix><strong>Adafruit_NeoMatrix</strong></a></li> <li><a href=https://github.com/adafruit/Adafruit_NeoPixel><strong>Adafruit_NeoPixel</strong></a></li> </ul> <p>Si no las tenemos instaladas procedemos a su descarga de los enlaces anteriores y a su instalación siguiendo el proceso descrito en el punto "Gestor de librerías" del apartado <a href=../softIDE/ >IDE 2</a>.</p> <p>Si estamos utilizando un IDE anterior a la versión (1.8.10) también debemos tener instalada la librería <strong>BusIO</strong>.</p> <p>Por lo tanto, todos nuestros programas o sketches deben incluir como cabecera las tres líneas de código siguientes:</p> <div class=highlight><pre><span></span><code>#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_NeoMatrix.h&gt;
#include &lt;Adafruit_NeoPixel.h&gt;
</code></pre></div> <h3 id=libreria-gfx><font color=#AA0000>Librería GFX</font><a class=headerlink href=#libreria-gfx title="Permanent link">&para;</a></h3> <p>Se trata de una librería que nos proporciona un conjunto de funciones gráficas que incluyen líneas, círculos y texto y que se utilizan de forma habitual en pantallas LCD y OLED. Utiliza un sistema de coordenadas y unidades que permiten referenciar cada pixel a partir de un punto o coordenada de origen (0,0) que se sitúa en la esquina superior izquierda, de maneera que X es positivo hacia la derecha e Y hacía abajo. Es posible aplicar hasta cuatro rotaciones para indicar que esquina de la pantalla representa la parte superior izquierda.</p> <p>Las coordenadas siempre se expresan en pixeles, lo que implica que no existe una escala de medida real como el milímetro, y por lo tanto el tamaño de un determinado gráfico es función del tamaño del punto o de la densidad de pixeles de la pantalla en la que se muestra. El número de puntos de una pantalla se suele indicar en su datasheet o bien calcular midiendo el ancho de la misma y dividiendo por la cantidad de pixeles.</p> <p>Aunque cada pantalla concreta va a disponer de sus propias funciones constructoras e inicializadoras existen una serie de prototipos que son:</p> <ul> <li><strong>Dibujar pixles (puntos)</strong>. Lo más básico que podemos dibujar en una pantalla es un punto a partir de especificar su coordenada X,Y y su color:</li> </ul> <div class=highlight><pre><span></span><code>void  drawPixel (uint16_t x, uint16_t y, uint16_t color);
</code></pre></div> <ul> <li><strong>Dibujar líneas</strong>. Debemos especificar el punto inicial, el punto final y el color:</li> </ul> <div class=highlight><pre><span></span><code>void drawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t color);
</code></pre></div> <p>Si se trata de líneas horizontales o verticales tenemos las dos funciones siguientes:</p> <div class=highlight><pre><span></span><code>void drawFastVLine(uint16_t x0, uint16_t y0, uint16_t length, uint16_t color); // Vertical
void drawFastHLine(uint8_t x0, uint8_t y0, uint8_t length, uint16_t color); // Horizontal
</code></pre></div> <ul> <li><strong>Rectángulos</strong>. Se pueden crear cuadrados o rectángulos, que se pueden rellenar o no, utilizando los siguientes procedimientos:</li> </ul> <div class=highlight><pre><span></span><code>void drawRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color);
void fillRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color);
</code></pre></div> <p>La anchura se especifica en las coordenadas X y la altura se especifica en las coordenadas Y.</p> <ul> <li><strong>Círculos</strong>. También los círculos se pueden rellenar y dibujar indicando en este caso el centro el primer par X,Y y el radio el segundo par X,Y. Los procedimientos son:</li> </ul> <div class=highlight><pre><span></span><code>void drawCircle(uint16_t x0, uint16_t y0, uint16_t r, uint16_t color);
void fillCircle(uint16_t x0, uint16_t y0, uint16_t r, uint16_t color);
</code></pre></div> <ul> <li><strong>Rectángulos redondeados</strong>. También pueden dibujarse y rellenarse. En primer lugar se indican el ancho y el alto como en rectángulos normales, luego se indica el radio de las esquinas (en pixeles) y finalmente se indica el color.</li> </ul> <div class=highlight><pre><span></span><code>void drawRoundRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t radius, uint16_t color);
void fillRoundRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t radius, uint16_t color);
</code></pre></div> <ul> <li><strong>Triángulos</strong>. De nuevo está disponible la opción de relleno. En esta ocasión se requieren un par de coordenadas para cada vértice seguidas de un color:</li> </ul> <div class=highlight><pre><span></span><code>void drawTriangle(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color);
void fillTriangle(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color);
</code></pre></div> <ul> <li><strong>Caracteres y texto</strong>. Si queremos añadir un solo carácter indicamos la coordenada donde lo posicionamos, el color y el color de fondo. Opcionalmente se puede añadir otro parámetro para escalar la fuente en un determinado factor, por ejemplo size=2 pondrá la fuente en un tamaño de 10x16 pixeles.</li> </ul> <div class=highlight><pre><span></span><code>void drawChar(uint16_t x, uint16_t y, char c, uint16_t color, uint16_t bg, uint8_t size);
</code></pre></div> <p>Para escribir una cadena lo que se hace es configurar los parámetros en procedimientos separados y finalmente se usa la función <em>'print()' o bien 'println'</em>, como vemos a continuación:</p> <div class=highlight><pre><span></span><code>void setCursor(int16_t x0, int16_t y0);
void setTextColor(uint16_t color);
void setTextColor(uint16_t color, uint16_t backgroundcolor);
void setTextSize(uint8_t size);
void setTextWrap(boolean w);
println(&quot;Hola&quot;);
void setTextSize(2);
println(&quot;4321.98);
void setTextSize(3);
println(0xABCDEFG, HEX);void fillScreen(uint16_t color);
</code></pre></div> <p>Comienza con <em>setCursor(x, y)</em>, que sitúa la esquina superior izquierda del texto, por defecto es (0,0), luego establecemos el color del texto con setTextColor(color), que por defecto es blanco. El texto normalmente se dibuja en color "claro" pero si queremos se puede especificar un color de fondo como segundo parámetro opcional para setTextColor(). Finalmente, setTextSize(size) multiplicará la escala del texto por un factor entero dado.</p> <p>De forma predeterminada, las líneas largas de texto están configuradas para "ajustarse" automáticamente a la columna más a la izquierda. Para anular este comportamiento se utiliza <em>'setTextWrap(false)'</em>. El comportamiento de ajuste normal se restaura con <em>'setTextWrap(true)'</em>.</p> <ul> <li><strong>Mapas de bits</strong>. Es posible dibujar mapas de bits monocromáticos.</li> </ul> <div class=highlight><pre><span></span><code>void drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h, uint16_t color);
</code></pre></div> <p>Esto crea un bloque contiguo de bits en la pantalla, donde cada bit '1' ilumina el píxel correspondiente en 'color', mientras que se omite cada bit '0'. las coordenadas x,y fijan la esquina superior izquierda donde se dibuja el mapa de bits, w, h son el ancho y el alto en píxeles. Los datos del mapa de bit deben estar en la memoria de programa.</p> <ul> <li><strong>Limpiar o rellenar la pantalla</strong>. Se trata de una función que configura toda la pantalla en un color dado. Si el color es negro equivale a borrarla ya que todos los LEDs se ponen en negro, es decir se apagan.</li> </ul> <div class=highlight><pre><span></span><code>void fillScreen(uint16_t color);
</code></pre></div> <h3 id=libreria-neopixel><font color=#AA0000>Librería NeoPixel</font><a class=headerlink href=#libreria-neopixel title="Permanent link">&para;</a></h3> <p>Esta es la librería que hemos venido utilizando en ArduinoBlocks para trabajar con el panel como tira de LEDs direccionables. Para trabajar con tiras de LEDs son necesarias las siguientes tres líneas de código:</p> <div class=highlight><pre><span></span><code>#define LED_PIN 6 // Pin de datos
#define LED_COUNT 60 // Numero de LEDs de la tira
// Declaración del objeto NeoPixel strip:
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);
</code></pre></div> <p>Los parámetros o argumentos del objeto para una función como</p> <div class=highlight><pre><span></span><code>Adafruit_NeoPixel neo_pixel = Adafruit_NeoPixel(256,2,NEO_GRB+NEO_KHZ800);
</code></pre></div> <p>son los siguientes:</p> <ul> <li>1: Número de píxeles en la tira. LED_COUNT = 256</li> <li>2: Número de pin de Arduino. LED_PIN = 2</li> <li>3: Indicadores de tipo de píxel, la suma será alguna de estas combinaciones:<ul> <li>NEO_KHZ800 Flujo de bits de 800 KHz (la mayoría de los productos se hacen con LEDs WS2812)</li> <li>NEO_KHZ400 400 KHz (píxeles FLORA clásicos 'v1' (no v2), controladores WS2811)</li> <li>Los píxeles NEO_GRB están cableados para flujo de bits GRB (la mayoría de los productos)</li> <li>Los píxeles NEO_RGB están cableados para flujo de bits RGB (píxeles FLORA v1 , no v2)</li> <li>Los píxeles NEO_RGBW están cableados para el flujo de bits RGBW (productos NeoPixel RGBW)</li> </ul> </li> </ul> <p>Existen diferentes funciones para manejo de una tira de LEDs que no vamos a definir aquí pues ya están definidas en ArduinoBlocks.</p> <h3 id=libreria-neomatrix><font color=#AA0000>Librería NeoMatrix</font><a class=headerlink href=#libreria-neomatrix title="Permanent link">&para;</a></h3> <p>Se trata de una biblioteca o librería de <a href=https://www.adafruit.com/ >Adafruit</a>, basada en NeoPixel, que permite crear pantallas gráficas bidimensionales utilizando los paneles que estamos viendo. Esto nos va a permitir dibujar fácilmente formas, texto y animaciones sin tener que calcular la posición XY de cada píxel.</p> <p><strong>NeoMatrix de Adafruit</strong> utiliza el mismo sistema de coordenadas, funciones de color y comandos gráficos que la biblioteca GFX que hemos visto. Vamos a centrar nuestra atención en cómo declarar una pantalla bidimensional hecha a partir de LEDs direccionables o NeoPixels.</p> <p>La librería o biblioteca es capaz de manejar tanto matrices individuales (todos los LEDs en una sola cuadrícula uniforme) como matrices en mosaico (múltiples cuadrículas combinadas en una pantalla más grande):</p> <p><center></p> <p><img alt="Matrices simples o agrupadas" src=../../img/matriz8x32/simple_grupo.png></p> <p><em>Matrices simples o agrupadas</em></p> <p></center></p> <p>El siguiente paso es invocar a la directiva del preprocesador #ifndef para comprobar si la macro PSTR está definida. Esta macro (definida en <a href=https://github.com/esp8266/Arduino/blob/master/cores/esp8266/pgmspace.h>pgmspace.h</a>) sirve para declarar cadenas flash en un bloque de código para escribir y leer en la memoria de programa PROGMEM. Esto es conveniente hacerlo porque la librería utiliza la corrección gamma del color para minimizar el consumo. El código ahora estaría así:</p> <div class=highlight><pre><span></span><code>#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_NeoMatrix.h&gt;
#include &lt;Adafruit_NeoPixel.h&gt;

#ifndef PSTR
 #define PSTR
#endif
</code></pre></div> <p>Con esto estamos en condiciones de crear la declaración de nuestra matriz, lo que se hace mediante la siguiente línea de código:</p> <div class=highlight><pre><span></span><code>Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(WIDTH, HEIGTH, Hor, Ver, PIN, matrix_layout_flags);
</code></pre></div> <p>Con esto invocamos al constructor para que nos cree el elemento 'matriz' con los parámetros definidos entre paréntesis y separados por comas y que vamos a explicar a continuación:</p> <ul> <li><strong>Parámetro 1, WIDTH</strong>: Define el ancho de la matriz individual o de cada matriz en una agrupación (no del total de la pantalla)</li> <li><strong>Parámetro 2, HEIGTH</strong>: Define la altura de la matriz individual o de cada matriz en una agrupación</li> <li><strong>Parámetro 3, Hor</strong>: Número de matrices conectadas horizontalmente</li> <li><strong>Parámetro 4, Ver</strong>: Número de matrices conectadas verticalmente</li> <li><strong>Parámetro 5, PIN</strong>: Número de pin que usaremos como salida de datos de nuestra placa y que irá conectado a la entrada DIN de la matriz.</li> <li> <p><strong>Parámetro 6, matrix_layout_flags</strong>: Aquí es donde tenemos que definir las banderas o flags de diseño de nuestra matriz o pantalla (agrupación de matrices) y se hace sumando todos los que necesitemos de los siguientes:</p> <ul> <li><font color=#0000ff><em>Posición del primer LED de la primera matriz:</em></font></li> </ul> <p>NEO_MATRIX_TOP, NEO_MATRIX_BOTTOM, NEO_MATRIX_LEFT, NEO_MATRIX_RIGHT</p> <p>Por ejemplo: NEO_MATRIX_TOP + NEO_MATRIX_LEFT para esquina superior izquierda</p> <ul> <li><font color=#0000ff><em>Disposición de los LEDs en cada matriz:</em></font></li> </ul> <p>NEO_MATRIX_ROWS, NEO_MATRIX_COLUMNS: Elegimos uno u otro</p> <ul> <li><font color=#0000ff><em>Forma de conexionado de filas/columnas:</em></font></li> </ul> <p>NEO_MATRIX_PROGRESSIVE, NEO_MATRIX_ZIGZAG: Elegimos uno</p> <ul> <li><font color=#0000ff><em>Posición de la primera matriz en un mosaico:</em></font></li> </ul> <p>NEO_TILE_TOP, NEO_TILE_BOTTOM, NEO_TILE_LEFT, NEO_TILE_RIGHT</p> <p>Por ejemplo: NEO_TILE_TOP + NEO_TILE_LEFT para esquina superior izquierda</p> <ul> <li><font color=#0000ff><em>Disposición de las matrices en la pantalla:</em></font></li> </ul> <p>NEO_TILE_ROWS, NEO_TILE_COLUMNS: Elegimos uno u otro</p> <ul> <li><font color=#0000ff><em>Tipo de matriz:</em></font></li> </ul> <p>NEO_RGB, para pixeles V1 con flujo de datos (bitstream) RGB</p> <p>NEO_GRB, para pixeles V2 con flujo de datos (bitstream) GRB</p> <p>NEO_KHZ400, para bitstream de 400 KHz (por ejemplo pixeles FLORA V1)</p> <p>NEO_KHZ800, para bitstream de 800 KHz (por ejemplo tiras de alta densidad de LEDs)</p> </li> </ul> <p>Nuestro código podría continuar, por ejemplo, de la forma siguiente:</p> <div class=highlight><pre><span></span><code>#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_NeoMatrix.h&gt;
#include &lt;Adafruit_NeoPixel.h&gt;

#ifndef PSTR
 #define PSTR
#endif

#define PIN 3

Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(32, 8, 2, 1, PIN,
  NEO_TILE_TOP   + NEO_TILE_LEFT   + NEO_TILE_ROWS   + NEO_TILE_PROGRESSIVE +
  NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG,
  NEO_GRB + NEO_KHZ800);
</code></pre></div> <p>El constructor de la matriz nos facilita la siguiente información de ayuda:</p> <p><center></p> <p><img alt="Ayuda del constructor" src=../../img/matriz8x32/constructor.png></p> <p><em>Ayuda del constructor</em></p> <p></center></p> <p>Observamos como los parámetros 1 al 5 deben ser números enteros positivos de 8 bits, es decir, hasta 255.</p> <p>Un ejemplo de definición de una matriz de 32x8 en un solo panel podría ser como sigue:</p> <div class=highlight><pre><span></span><code>Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(32, 8, PIN,
  NEO_MATRIX_TOP     + NEO_MATRIX_RIGHT +
  NEO_MATRIX_COLUMNS + NEO_MATRIX_PROGRESSIVE,
  NEO_GRB            + NEO_KHZ800);
</code></pre></div> <p>El resto de tareas las vamos a ver utilizando un ejemplo comentado en el que usamos una pantalla de 64x8 pixeles formada a partir de 2 matrices de 32x8 pixeles en la que vamos a hacer que un texto se desplace cmabiando en cada iteración el color de las letras entre 8 posibles combinaciones. El ejemplo <a href=../../programas/NavidadConCiencia.zip>NavidadConCiencia</a> que puedes descargar del enlace tiene el siguiente código:</p> <div class=highlight><pre><span></span><code>// Invocamos librerías
#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_NeoMatrix.h&gt;
#include &lt;Adafruit_NeoPixel.h&gt;

// Definimos patilla de salida de datos
#define PIN 3

//Creamos el objeto matriz
Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, 2, 1, PIN,     
  NEO_MATRIX_BOTTOM  + NEO_MATRIX_RIGHT +
  NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
  NEO_GRB            + NEO_KHZ800);

// Definimos vectores de colores
  const uint16_t colors[] = {
    matriz.Color(255, 0, 0), matriz.Color(0, 255, 0), matriz.Color(255, 255, 0),
    matriz.Color(0, 0, 255), matriz.Color(255, 0, 255), matriz.Color(0, 255, 255), 
    matriz.Color(255, 128, 0), matriz.Color(255, 255, 255)};

void setup()
{ matriz.begin(); // Iniciamos el objeto
  matriz.setTextWrap(false); // Relativo a si se recorta o no el texto si es mayor que la matriz
  matriz.setBrightness(15); // Establece el brillo en un 15%
  matriz.setTextColor(colors[0]); // Se establece el primer color como inicial
}

int x = matriz.width(); // Calculo de la anchura de la matriz
int pases = 0; // Pasadas para el cambio de color

void loop(){
  matriz.fillScreen(0);    //Apaga todos los LEDs
  matriz.setCursor(x, 0); // Coloca el cursor en la posición  64,0 en este caso concreto
  char cadena[] = &quot;Parque de las Ciencias - openLAB - Club Robotica Granada&quot;; // Cadena a mostrar
  int longitud_cadena = strlen(cadena); // Número de caracteres de la cadena
  int longitud_pixels = longitud_cadena * 6; // Cada caracter ocupa 5 pixeles mas un espacio, en total 6 pixeles
  matriz.print((cadena)); // Mostrar la cadena
if( --x &lt; -longitud_pixels ) // Decremento de la posición X en función de la variable
   {   x = matriz.width(); // Reiniciamos la variable
       if(++pases &gt;= 8) pases = 0; // Comprobamos si hemos llegado al último vector de color
       matriz.setTextColor(colors[pases]); // Establce el color según el índice del vector
   }
  matriz.show(); // Muestra la pantalla
  delay(100);
}  
</code></pre></div> <p>La declaración del objeto matriz también se puede hacer de la forma siguiente:</p> <div class=highlight><pre><span></span><code>Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(64, 8, PIN,     
  NEO_MATRIX_BOTTOM  + NEO_MATRIX_RIGHT +
  NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
  NEO_GRB            + NEO_KHZ800);
</code></pre></div> <p>En el video siguiente podemos ver el resultado de este programa.</p> <p><center></p> <iframe width=560 height=315 src=https://www.youtube.com/embed/9vvprexIAyc title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe> <p></center></p> <h2 id=dibujos-basicos><font color=#007575><strong>Dibujos básicos</strong></font><a class=headerlink href=#dibujos-basicos title="Permanent link">&para;</a></h2> <p>Veremos ejemplos simples de uso de la librería para crear dibujos sencillos como dibujar un pixel, un cuadrado relleno o no, líneas, cŕculos rellenos o no y como poner un texto fijo.</p> <h3 id=pixeles-y-cuadrados><font color=#AA0000>Pixeles y cuadrados</font><a class=headerlink href=#pixeles-y-cuadrados title="Permanent link">&para;</a></h3> <p>Lo más sencillo que podemos dibujar es un pixel de un color determinado y para ello basta con invocar el siguiente comando:</p> <div class=highlight><pre><span></span><code>// dibujar un pixel de color blanco
  matriz.drawPixel(x, y, matrix.Color(R, G, B));
</code></pre></div> <p>Para dibujar un contorno rectangular relleno haremos lo siguiente:</p> <div class=highlight><pre><span></span><code>// dibujar un rectangulo sólido
  matriz.fillRect(xi, yi, xrf, yrf, matrix.Color(R, G, B));
</code></pre></div> <p>Damos las coordenadas del vértice inicial y las del opuesto en su diagonal, siendo estas últimas relativas pues se cuentan a partir de las iniciales.</p> <p>Para dibujar el contorno de un rectangulo haremos lo siguiente:</p> <div class=highlight><pre><span></span><code>// dibujar un rectangulo
  matriz.drawRect(xi, yi, xrf, yrf, matrix.Color(R, G, B));
</code></pre></div> <p>En el ejemplo siguiente se dibujan los cuatro pixeles centrales en color blanco, un rectángulo relleno, un rectángulo, otro rectángulo perimetral, un rectángulo que rodea a los pixeles y finalmente otro rectángulo sólido de color rojo en el interior del rectángulo verde. </p> <div class=highlight><pre><span></span><code>// Invocamos librerías
#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_NeoMatrix.h&gt;
#include &lt;Adafruit_NeoPixel.h&gt;

// Definimos patilla de salida de datos
#define PIN 3

//Creamos el objeto matriz
Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN,     
  NEO_MATRIX_BOTTOM  + NEO_MATRIX_RIGHT +
  NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
  NEO_GRB            + NEO_KHZ800);

void setup()
{ matriz.begin(); // Iniciamos el objeto### &lt;FONT COLOR=#AA0000&gt;Líneas y circulos&lt;/font&gt;

  matriz.setBrightness(15); // Establece el brillo en un 15%
}

int x = matriz.width(); // Calculo de la anchura de la matriz

void loop(){
  matriz.fillScreen(0);    //Apaga todos los LEDs
  delay(1000); matriz.show();
  matriz.setCursor(x, 0); // Coloca el cursor en la posición  31,0 en este caso concreto
// Pixeles de color blanco
  matriz.drawPixel(15, 3, matriz.Color(255, 255 ,255));
  matriz.drawPixel(15, 4, matriz.Color(255, 255 ,255));
  matriz.drawPixel(16, 3, matriz.Color(255, 255 ,255));
  matriz.drawPixel(16, 4, matriz.Color(255, 255 ,255));
  delay(500); matriz.show();
  // Cuadrado relleno de color verde
  matriz.fillRect(1,1,13,6, matriz.Color(0,255,0)); delay(1000); matriz.show();
  // Contorno de cuadrado en color verde
  matriz.drawRect(18,1,13,6, matriz.Color(0,255,0)); delay(1000); matriz.show();
  // Contorno cuadrado de color amarillo
  matriz.drawRect(0,0,32,8, matriz.Color(255,255,0)); delay(1000); matriz.show();
  // Contorno cuadrado de color azul
  matriz.drawRect(14,1,4,6, matriz.Color(0,0,255)); delay(1000); matriz.show();
  // Cuadrado relleno de color rojo
  matriz.fillRect(19,2,11,4, matriz.Color(255,0,0)); delay(1000); matriz.show();
}  
</code></pre></div> <p>La secuencia de imágenes siguiente es el resultado de cargar el programa <a href=../../programas/dibujo_rectangulos.zip>dibujo_rectangulos</a> en un Keyestudio UNO.</p> <p><center></p> <p><img alt="Ejemplo de dibujo de pixeles y rectángulos" src=../../img/matriz8x32/pixel_rectangulo.png></p> <p><em>Ejemplo de dibujo de pixeles y rectángulos</em></p> <p></center></p> <h3 id=lineas-y-circulos><font color=#AA0000>Líneas y circulos</font><a class=headerlink href=#lineas-y-circulos title="Permanent link">&para;</a></h3> <p>Para dibujar líneas damos las coordinadas del punto inicial y del punto final seguidas del código de color, o sea haremos:</p> <div class=highlight><pre><span></span><code>// dibujar una linea
  matriz.drawLine(xi, yi, xf, yf, matrix.Color(R, G, B));
</code></pre></div> <p>Para dibujar circulos rellenos damos las coordenadas del centro y el radio, o sea hacemos lo siguiente:</p> <div class=highlight><pre><span></span><code>// dibujar un círculo relleno
  matriz.fillCircle(x0, y0, r, matrix.Color(R, G, B));
</code></pre></div> <p>Para dibujar un círculo la forma de proceder es:</p> <div class=highlight><pre><span></span><code>// dibujar un circulo
  matriz.drawCircle(x0, y0, r, matrix.Color(R, G, B));
</code></pre></div> <p>En el ejemplo <a href=../../programas/dibujo_lineas_circulos.zip>dibujo_lineas_circulos</a> vemos algunos casos de estos dos dibujos y a continuación tenemos el código del programa completo.</p> <div class=highlight><pre><span></span><code>// Invocamos librerías
#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_NeoMatrix.h&gt;
#include &lt;Adafruit_NeoPixel.h&gt;

// Definimos patilla de salida de datos
#define PIN 3

//Creamos el objeto matriz
Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN,     
  NEO_MATRIX_BOTTOM  + NEO_MATRIX_RIGHT +
  NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
  NEO_GRB            + NEO_KHZ800);

void setup()
{ matriz.begin(); // Iniciamos el objeto
  matriz.setBrightness(15); // Establece el brillo en un 15%
}

int x = matriz.width(); // Calculo de la anchura de la matriz

void loop(){
  matriz.fillScreen(0);    //Apaga todos los LEDs
  delay(1000); matriz.show();
  matriz.setCursor(x, 0); // Coloca el cursor en la posición  31,0 en este caso concreto
  // Hacer una X roja que ocupa la mitad de la matriz
  matriz.drawLine(0, 0, 16, 7, matriz.Color(255, 0 ,0)); 
  matriz.drawLine(16, 0, 0, 7, matriz.Color(255, 0 ,0)); 
  // Hacer una X azul que ocupa la otra mitad de la matriz
  matriz.drawLine(17, 0, 31, 7, matriz.Color(0, 0 ,255)); 
  matriz.drawLine(31, 0, 17, 7, matriz.Color(0, 0 ,255));
  // Dibujar circulos
  matriz.fillCircle(2,4,1, matriz.Color(255,0,255));
  matriz.fillCircle(30,3,1, matriz.Color(255,0,255)); 
  matriz.drawCircle(17,4,2, matriz.Color(0,255,255)); 
  matriz.show();
}  
</code></pre></div> <p>En la figura siguiente vemos el resultado.</p> <p><center></p> <p><img alt="Ejemplo de dibujo de líneas y círculos" src=../../img/matriz8x32/lin_cir.png></p> <p><em>Ejemplo de dibujo de líneas y círculos</em></p> <p></center></p> <h3 id=textos><font color=#AA0000>Textos</font><a class=headerlink href=#textos title="Permanent link">&para;</a></h3> <p>Para mostrar textos lo primero que debemos hacer es establecer la ubicación del cursor con <em>setCursor</em>. Debemos tener en cuenta que los caracteres de texto tienen una altura de 8 píxeles de forma predeterminada y la posición del primer pixel del primer caracter. Con <em>setTextSize</em> podemos establecer el tamaño en 1 (8 píxeles de alto) o 2 (16 píxeles de alto) y finalmente debemos establecer el color del texto con <em>setTextColor</em>. Una vez hecho todo esto, podemos usar print('1') para imprimir el carácter "1".</p> <p>El ejemplo <a href=../../programas/textos.zip>Textos</a> nos va a ir mostrando a intervalos de dos segundos las cadenas "-RGB-", "32x8" y "Pixel" en diferentes colores y el código es el siguiente:</p> <div class=highlight><pre><span></span><code>// Invocamos librerías
#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_NeoMatrix.h&gt;
#include &lt;Adafruit_NeoPixel.h&gt;

// Definimos patilla de salida de datos
#define PIN 3

//Creamos el objeto matriz
Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN,     
  NEO_MATRIX_TOP  + NEO_MATRIX_LEFT +
  NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
  NEO_GRB            + NEO_KHZ800);

void setup()
{ matriz.begin(); // Iniciamos el objeto
  matriz.setBrightness(15); // Establece el brillo en un 15%
}

void loop(){
  matriz.fillScreen(0);    //Apaga todos los LEDs
  matriz.setTextSize(1); // 1 == 8 pixeles
  matriz.setCursor(1, 0); // Coloca el cursor en la posición 4,0 en este caso concreto
  matriz.setTextColor(matriz.Color(255,0,0));
  matriz.print(&#39;-&#39;);
  matriz.setTextColor(matriz.Color(255,127,0));
  matriz.print(&#39;R&#39;);
  matriz.setTextColor(matriz.Color(255,255,0));
  matriz.print(&#39;G&#39;);
  matriz.setTextColor(matriz.Color(127,255,0));
  matriz.print(&#39;B&#39;);
  matriz.setTextColor(matriz.Color(0,127,0));
  matriz.print(&#39;-&#39;);
  matriz.show();
  delay(2000);
  matriz.fillScreen(0);    //Apaga todos los LEDs
  matriz.setCursor(4, 0); // Coloca el cursor en la posición 4,0 en este caso concreto
  matriz.setTextColor(matriz.Color(0,255,255));
  matriz.print(&#39;3&#39;);
  matriz.setTextColor(matriz.Color(0,127,255));
  matriz.print(&#39;2&#39;);
  matriz.setTextColor(matriz.Color(127,0,255));
  matriz.print(&#39;x&#39;);
  matriz.setTextColor(matriz.Color(127,0,127));
  matriz.print(&#39;8&#39;);
  matriz.show();
  delay(2000);
  matriz.fillScreen(0);    //Apaga todos los LEDs
  matriz.setCursor(2, 0); // Coloca el cursor en la posición 4,0 en este caso concreto
  matriz.setTextColor(matriz.Color(255,0,255));
  matriz.print(&#39;P&#39;);
  matriz.print(&#39;i&#39;);
  matriz.print(&#39;x&#39;);
  matriz.print(&#39;e&#39;);
  matriz.print(&#39;l&#39;);
  matriz.show();
  delay(2000);  
}  
</code></pre></div> <h2 id=uso-de-memoria-ram><font color=#007575><strong>Uso de memoria RAM</strong></font><a class=headerlink href=#uso-de-memoria-ram title="Permanent link">&para;</a></h2> <p>La librería NeoMatrix no consume más memoria que NeoPixel, ya que requiere 3 bytes de RAM por cada píxel. Ahora bien, la cantidad de píxeles en una pantalla bidimensional aumenta exponencialmente, como vemos haciendo unos cálculos sencillos:</p> <p><center></p> <p><span class=arithmatex><span class=MathJax_Preview>Pantalla \space de \space 8x8 \space = \space 64 \implies Memoria \space = \space 192 \space bytes</span><script type=math/tex>Pantalla \space de \space 8x8 \space = \space 64 \implies Memoria \space = \space 192 \space bytes</script></span></p> <p><span class=arithmatex><span class=MathJax_Preview>Pantalla \space de \space 16x16 \space = \space 256 \implies Memoria \space = \space 768 \space bytes</span><script type=math/tex>Pantalla \space de \space 16x16 \space = \space 256 \implies Memoria \space = \space 768 \space bytes</script></span></p> <p><span class=arithmatex><span class=MathJax_Preview>64 \times 4 \space = \space 256 \space y \space 192 \times 4 \space = 768</span><script type=math/tex>64 \times 4 \space = \space 256 \space y \space 192 \times 4 \space = 768</script></span></p> <p></center></p> <p>Es decir, que una pantalla de 16x16 requiere cuatro veces mas memoria que una pantalla de 8x8, o aproximadamente de 768 bytes de RAM. Teniendo en cuenta que una placa UNO o nano tienen disponible una memoria SRAM de 2 kbytes, podemos decir que una matriz de 16x16 consume casi la mitad de esa memoria. Puede ser complicado o imposible combinar pantallas grandes con bibliotecas que consumen mucha memoria.</p> <h2 id=correccion-gamma><font color=#007575><strong>Corrección gamma</strong></font><a class=headerlink href=#correccion-gamma title="Permanent link">&para;</a></h2> <p>La respuesta a la luz del ojo humano tiene forma logarítmica, lo que significa que cuando vemos una escala de grises, nos parece que el brillo aumenta de forma continua, pero la cantidad real de luz aumenta de forma exponencial, y ese exponente es lo que se conoce como <strong><em>Gamma</em></strong>. Como referencia, un valor de gamma habitual es 2,4, es decir que cada valor tiene 2,4 veces la cantidad de luz del valor anterior. Este comportamiento exponencial ocurría en aparatos con tubos de vacio. Actualmente se utilizan; en monitores LCD, plasma u OLED, sensores de estado sólido, y estos tienen una respuesta lineal o muy aproximada.</p> <p>Esto nos da pie a pensar que <strong><em>Gamma</em></strong> es algo que está obsoleto, pero nada mas lejos de la realidad, ya que está totalmente de actualidad debido a que es un método de compresión muy eficaz, con el que nos aseguramos que sólo se asignan, se guardan y se transmiten valores (y diferencias de valores) que son visibles por el ojo humano, y que no se usan bits para codificar incrementos de brillo que el ojo no va a percibir.</p> <p>Podemos encontrar mucha mas información sobre <a href="https://www.benq.eu/es-es/knowledge-center/knowledge/gamma-monitor.html#:~:text=Gamma%20se%20puede%20describir%20como,o%20de%20blanco%20a%20negro.">¿Qué es gamma?</a> en el enlace.</p> <p>La librería GFX se diseñó originalmente para pantallas LCD (con una fidelidad de color limitada), manejando los colores como valores de 16 bits (en lugar de los 24 bits completos de los que son capaces los NeoPixels). Esta no es la gran pérdida que podría parecer. Una peculiaridad de la visión humana hace que los colores brillantes sean menos perceptibles que los tenues. La biblioteca NeoMatrix utiliza la corrección gamma para seleccionar niveles de brillo que son visualmente (aunque no numéricamente) equidistantes. Hay 32 niveles para rojo y azul, 64 niveles para verde.</p> <p>La función <em>Color()</em> realiza la conversión necesaria; no necesitas hacer ningún cálculo. Acepta valores de rojo, verde y azul de 8 bits y devuelve un color de 16 bits con corrección gamma que luego se puede pasar a otras funciones de dibujo.</p> </article> </div> </div> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Pie> <a href=../alimentar/ class="md-footer__link md-footer__link--prev" aria-label="Anterior: Alimentación" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Anterior </span> Alimentación </div> </div> </a> <a href=../matriz16x16/ class="md-footer__link md-footer__link--next" aria-label="Siguiente: Matriz WS2812 16x16" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Siguiente </span> Matriz WS2812 16x16 </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2020 - 2035 Federico Coca </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-social> <a href=https://twitter.com/fgcoca target=_blank rel=noopener title="Twitter de Federico Coca" class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg> </a> <a href=https://github.com/fgcoca target=_blank rel=noopener title="Github de Federico Coca" class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a> <a href="https://www.instagram.com/cocafederico/?hl=es" target=_blank rel=noopener title="Instagram de Federico Coca" class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg> </a> <a href=https://twitter.com/clubroboticagra target=_blank rel=noopener title="Twitter de Club Robótica Granada" class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.config.lang": "es", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "B\u00fasqueda", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version.title": "Seleccionar versi\u00f3n"}}</script> <script src=../../assets/javascripts/bundle.5a2dcb6a.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>