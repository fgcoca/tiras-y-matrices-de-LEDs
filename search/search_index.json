{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tiras y matrices de LEDs \u00b6 B\u00e1sicamente vamos a dar unas notas sobre algunos de estos elementos. El tema ser\u00e1 tratado tanto desde el entorno gr\u00e1fico de ArduinoBlocks como desde el IDE de Arduino. Las placas controladoras que m\u00e1s utilizar\u00e9 son las de las figuras siguientes, o similares. Placa tipo que se utilizan Diodo LED \u00b6 El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz cuando se polariza directamente, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la figura siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores Matriz de 8x8 LEDs \u00b6 Es una pantalla o distribuci\u00f3n de 8x8 LEDs en la que podemos programar diferentes s\u00edmbolos o elementos, como: caras, iconos, letras... Hay opciones predise\u00f1adas desde ArduinoBlocks y tambi\u00e9n, existe la opci\u00f3n de crearlos personalizados. Se trata de dispositivos I2C y su aspecto, cuando no podemos cambiar su direcci\u00f3n f\u00edsica, es el de la figura siguiente. Aspecto de la matriz de 8x8 Este tipo de matrices son 'multiplexadas', por lo que para controlar 64 LED necesitamos 16 pines y eso son muchos pines aunque hay chips de controladores como el MAX7219 que pueden controlar una matriz, pero a\u00fan as\u00ed hay mucho cableado que configurar y ocupan muchos pines. Para solucionar esto se utiliza un chip de control que tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s del m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El conjunto forma una matriz de 8x8 que se controla a trav\u00e9s de una interfaz I2C. Sus principales caracter\u00edsticas son: Matriz de LEDs de 8 filas y 8 columnas Direccionada por un chip HT16K33 Conexi\u00f3n tipo I2C Tensi\u00f3n de alimentaci\u00f3n: 5V Frecuencia de trabajo: 400KHz Potencia de entrada: 2.5W Corriente de entrada: 500mA Tambi\u00e9n existen matrices que son direccionables , como la que vemos en la imagen siguiente: Aspecto de la matriz de 8x8 direccionable LED RGB y matrices RGB \u00b6 Un LED RGB es en realidad un encapsulado que incorpora tled rgbres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. Colores RGB Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB. El s\u00edmbolo y la representaci\u00f3n mas comunes de este componente lo vemos en la imagen siguiente: S\u00edmbolo y representaci\u00f3n LED RGB El aspecto del componente en sus versiones inserci\u00f3n y SMD lo vemos en la imagen siguiente: Aspecto LED RGB Estos LEDs se pueden agrupar en forma de matrices de diferentes n\u00fameros de LEDs ordenados por filas y columnas. En la figura siguiente vemos una muestra de este tipo de matrices. Matrices de LED RGB La fila inferior corresponde a elemento normalmente utilizados en iluminaci\u00f3n profesional y espect\u00e1culos que se controlan mediante dispositivos DMX y que suelen tener potencias elevadas. LED RGB direccionable \u00b6 Com\u00fanmente se les conoce como Neopixel, que es una marca registrada por Adafruit Industries . Cada LED que componen la tira o matriz tiene los siguientes cuatro pines: Alimentaci\u00f3n VDD: 5V Tierra: GND DI (Date Input): pin para recibir informaci\u00f3n DO (Date Output): pin para enviar inforamci\u00f3n Cada uno de los LEDs es direccionable de manera individual gracias al circuito electr\u00f3nico que incluyen que es un circuito l\u00f3gico con una memoria de un byte por color. Los tipos mas comunes son el SK6812, WS2811 o, el mas habitual de todos, el WS2812 cuyo datasheet tenemos en el enlace. El WS2812B incluye un oscilador interno de precisi\u00f3n y un circuito de control de corriente constante programable de 12 V, lo que garantiza de manera efectiva que la intensidad del color sea consistente. El protocolo de transferencia de datos utiliza un \u00fanico modo de comunicaci\u00f3n de multiplexado NZR. En la figura siguiente vemos el aspecto de un diodo LED RGB individual en formato inserci\u00f3n y SMD. Aspecto de un diodo LED RGB direccionable Aspectos previos \u00b6 Para transmitir informaci\u00f3n digital esta se debe sincronizar mediante una convenci\u00f3n especial, la codificaci\u00f3n. Dos dispositivos llevan una comunicaci\u00f3n por cable convirtiendo la informaci\u00f3n a transmitir en un flujo de bits (0 y 1) o \"Dates\" que se suele nombrar con la letra D y que va acompa\u00f1ada de una se\u00f1al de reloj para sincronizar las transmisiones. La forma convencional de transmisi\u00f3n digital se componen de una l\u00ednea de datos mas una l\u00ednea de reloj. Ahora bien, cualquier ligera desviaci\u00f3n en la longitud de estas l\u00edneas har\u00e1 que el receptor no cumpla con el tiempo de establecimiento del muestreo de datos, originando errores en los datos. La forma de asegurar que esas l\u00edneas son id\u00e9nticas es que sean la misma l\u00ednea, lo que hace que aparezcan c\u00f3digos que fusionan los datos y el reloj, entre los que est\u00e1n los c\u00f3digo RZ, NRZ y NRZI que vamos a ver someramente a continuaci\u00f3n. Codificaci\u00f3n RZ . El acr\u00f3nimo de de \"Return Zero\" o retorno cero y su caracter\u00edstica es que se transmiten bits de datos dentro de cada periodo de la se\u00f1al. En la figura siguiente los datos se representan en rojo y vemos que ocupan una parte del periodo T, siendo y matrices RGBcero el resto del tiempo. Este sistema se denomina RZ unipolar o retorno a cero unipolar y como se observa en la figura un nivel bajo indica 0 y un nivel positivo indica 1. C\u00f3digo RZ unipolar El c\u00f3digo de retorno a cero se divide en un c\u00f3digo de retorno a cero unipolar y un c\u00f3digo de retorno a cero bipolar en el que el nivel alto indica 1 y el nivel negativo o, tal y como vemos en la figura siguiente: C\u00f3digo RZ bipolar Codificaci\u00f3n NRZ . El acr\u00f3nimo es de \"Not Return Zero\" o c\u00f3digo sin retorno a cero y se diferencia del RZ en que no necesita retornar a cero. En la figura siguiente vemos gr\u00e1ficamente el c\u00f3digo. C\u00f3digo NRZ En el datasheet estos c\u00f3digo se denominan T0H y T0L. El funcionamiento de una agrupaci\u00f3n en cascada como la de la figura siguiente se puede resumir diciendo que: el circuito integrado de cada LED puede almacenar 3 bytes (24 bits), un byte para cada color. Solo el primer LED est\u00e1 conectado al Pin de control, en este caso, un pin digital de nuestra placa, que enviar\u00e1 la cadena de todos los colores seg\u00fan el n\u00famero de pixeles que est\u00e9n conectados y a su vez el primer LED recibir\u00e1 la informaci\u00f3n de todos los colores uno tras otro. La informaci\u00f3n se transmite de un LED a otro porque cuando un LED recibe 3 bytes nuevos de informaci\u00f3n entrega al siguiente LED los 3 bytes que conten\u00eda anteriormente, de esta manera cuando la placa con el programa termina de mandar todos los colores por el pin de datos el primer LED habr\u00eda recibido y enviado todos los colores para quedarse finalmente con el color que le corresponde y as\u00ed el resto de LEDs. De esta forma una tira de LEDs RGB direccionables es un dispositivo digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo.digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo. Conexi\u00f3n en cascada Aspectos t\u00e9cnicos \u00b6 Los LEDs RGB direccionables se suelen suministrar en tiras de diferentes longitudes y con distinto n\u00famero de LEDs y a veces se dispone la tira en forma de matriz. En la figura siguiente vemos el aspecto de algunos tipos. Tira y matriz de LEDs RGB Tienen 3 cables asociados a un conector y dos cables extra para a\u00f1adir alimentaci\u00f3n externa cuando es necesario porque la placa de control no entrega suficiente corriente para alimentar al conjunto. Cuando se trabaja con una tira de pocos LEDs no es necesario a\u00f1adir esta alimentaci\u00f3n externa, ya que placas como Arduino UNO o la ESP32 STEAMakers pueden suministrar la corriente que necesitan. En la figura siguiente vemos una tira de 8 LEDs: Tira de ocho LEDs RGB Cualquier tira de LEDs RGB (sea cual sea su disposici\u00f3n en l\u00ednea, como matriz, etc) debe utilizarse siempre en la direcci\u00f3n que marca el terminal hembra como entrada y el conector macho como salida. Las podemos ir conectando entre s\u00ed pero siempre respetando este sentido de la tira. Junto a cada led RGB est\u00e1 indicada la direcci\u00f3n de la tira mediante un tri\u00e1ngulo y tambi\u00e9n a qu\u00e9 pin debe ir conectado cada cable. Vemos +5V que corresponde a Vcc, GND, y en medio que pone Din o D0 que corresponde al pin digital de entrada de datos que debemos conectar al pin de salida de la placa de control. Tambi\u00e9n las podemos cortar por cualquiera de las l\u00edneas existentes entre cada uno de los LEDs y que est\u00e1 marcado con la l\u00ednea de corte. El corte debe hacerse dejando la mitad del pad de cobre a un lado y otro de la l\u00ednea y as\u00ed poder unir despu\u00e9s entre ellas con conectores especializados o sold\u00e1ndolas. Direcci\u00f3n y l\u00ednea de corte","title":"Introducci\u00f3n"},{"location":"#tiras-y-matrices-de-leds","text":"B\u00e1sicamente vamos a dar unas notas sobre algunos de estos elementos. El tema ser\u00e1 tratado tanto desde el entorno gr\u00e1fico de ArduinoBlocks como desde el IDE de Arduino. Las placas controladoras que m\u00e1s utilizar\u00e9 son las de las figuras siguientes, o similares. Placa tipo que se utilizan","title":"Tiras y matrices de LEDs"},{"location":"#diodo-led","text":"El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz cuando se polariza directamente, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la figura siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores","title":"Diodo LED"},{"location":"#matriz-de-8x8-leds","text":"Es una pantalla o distribuci\u00f3n de 8x8 LEDs en la que podemos programar diferentes s\u00edmbolos o elementos, como: caras, iconos, letras... Hay opciones predise\u00f1adas desde ArduinoBlocks y tambi\u00e9n, existe la opci\u00f3n de crearlos personalizados. Se trata de dispositivos I2C y su aspecto, cuando no podemos cambiar su direcci\u00f3n f\u00edsica, es el de la figura siguiente. Aspecto de la matriz de 8x8 Este tipo de matrices son 'multiplexadas', por lo que para controlar 64 LED necesitamos 16 pines y eso son muchos pines aunque hay chips de controladores como el MAX7219 que pueden controlar una matriz, pero a\u00fan as\u00ed hay mucho cableado que configurar y ocupan muchos pines. Para solucionar esto se utiliza un chip de control que tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s del m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El conjunto forma una matriz de 8x8 que se controla a trav\u00e9s de una interfaz I2C. Sus principales caracter\u00edsticas son: Matriz de LEDs de 8 filas y 8 columnas Direccionada por un chip HT16K33 Conexi\u00f3n tipo I2C Tensi\u00f3n de alimentaci\u00f3n: 5V Frecuencia de trabajo: 400KHz Potencia de entrada: 2.5W Corriente de entrada: 500mA Tambi\u00e9n existen matrices que son direccionables , como la que vemos en la imagen siguiente: Aspecto de la matriz de 8x8 direccionable","title":"Matriz de 8x8 LEDs"},{"location":"#led-rgb-y-matrices-rgb","text":"Un LED RGB es en realidad un encapsulado que incorpora tled rgbres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. Colores RGB Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB. El s\u00edmbolo y la representaci\u00f3n mas comunes de este componente lo vemos en la imagen siguiente: S\u00edmbolo y representaci\u00f3n LED RGB El aspecto del componente en sus versiones inserci\u00f3n y SMD lo vemos en la imagen siguiente: Aspecto LED RGB Estos LEDs se pueden agrupar en forma de matrices de diferentes n\u00fameros de LEDs ordenados por filas y columnas. En la figura siguiente vemos una muestra de este tipo de matrices. Matrices de LED RGB La fila inferior corresponde a elemento normalmente utilizados en iluminaci\u00f3n profesional y espect\u00e1culos que se controlan mediante dispositivos DMX y que suelen tener potencias elevadas.","title":"LED RGB y matrices RGB"},{"location":"#led-rgb-direccionable","text":"Com\u00fanmente se les conoce como Neopixel, que es una marca registrada por Adafruit Industries . Cada LED que componen la tira o matriz tiene los siguientes cuatro pines: Alimentaci\u00f3n VDD: 5V Tierra: GND DI (Date Input): pin para recibir informaci\u00f3n DO (Date Output): pin para enviar inforamci\u00f3n Cada uno de los LEDs es direccionable de manera individual gracias al circuito electr\u00f3nico que incluyen que es un circuito l\u00f3gico con una memoria de un byte por color. Los tipos mas comunes son el SK6812, WS2811 o, el mas habitual de todos, el WS2812 cuyo datasheet tenemos en el enlace. El WS2812B incluye un oscilador interno de precisi\u00f3n y un circuito de control de corriente constante programable de 12 V, lo que garantiza de manera efectiva que la intensidad del color sea consistente. El protocolo de transferencia de datos utiliza un \u00fanico modo de comunicaci\u00f3n de multiplexado NZR. En la figura siguiente vemos el aspecto de un diodo LED RGB individual en formato inserci\u00f3n y SMD. Aspecto de un diodo LED RGB direccionable","title":"LED RGB direccionable"},{"location":"#aspectos-previos","text":"Para transmitir informaci\u00f3n digital esta se debe sincronizar mediante una convenci\u00f3n especial, la codificaci\u00f3n. Dos dispositivos llevan una comunicaci\u00f3n por cable convirtiendo la informaci\u00f3n a transmitir en un flujo de bits (0 y 1) o \"Dates\" que se suele nombrar con la letra D y que va acompa\u00f1ada de una se\u00f1al de reloj para sincronizar las transmisiones. La forma convencional de transmisi\u00f3n digital se componen de una l\u00ednea de datos mas una l\u00ednea de reloj. Ahora bien, cualquier ligera desviaci\u00f3n en la longitud de estas l\u00edneas har\u00e1 que el receptor no cumpla con el tiempo de establecimiento del muestreo de datos, originando errores en los datos. La forma de asegurar que esas l\u00edneas son id\u00e9nticas es que sean la misma l\u00ednea, lo que hace que aparezcan c\u00f3digos que fusionan los datos y el reloj, entre los que est\u00e1n los c\u00f3digo RZ, NRZ y NRZI que vamos a ver someramente a continuaci\u00f3n. Codificaci\u00f3n RZ . El acr\u00f3nimo de de \"Return Zero\" o retorno cero y su caracter\u00edstica es que se transmiten bits de datos dentro de cada periodo de la se\u00f1al. En la figura siguiente los datos se representan en rojo y vemos que ocupan una parte del periodo T, siendo y matrices RGBcero el resto del tiempo. Este sistema se denomina RZ unipolar o retorno a cero unipolar y como se observa en la figura un nivel bajo indica 0 y un nivel positivo indica 1. C\u00f3digo RZ unipolar El c\u00f3digo de retorno a cero se divide en un c\u00f3digo de retorno a cero unipolar y un c\u00f3digo de retorno a cero bipolar en el que el nivel alto indica 1 y el nivel negativo o, tal y como vemos en la figura siguiente: C\u00f3digo RZ bipolar Codificaci\u00f3n NRZ . El acr\u00f3nimo es de \"Not Return Zero\" o c\u00f3digo sin retorno a cero y se diferencia del RZ en que no necesita retornar a cero. En la figura siguiente vemos gr\u00e1ficamente el c\u00f3digo. C\u00f3digo NRZ En el datasheet estos c\u00f3digo se denominan T0H y T0L. El funcionamiento de una agrupaci\u00f3n en cascada como la de la figura siguiente se puede resumir diciendo que: el circuito integrado de cada LED puede almacenar 3 bytes (24 bits), un byte para cada color. Solo el primer LED est\u00e1 conectado al Pin de control, en este caso, un pin digital de nuestra placa, que enviar\u00e1 la cadena de todos los colores seg\u00fan el n\u00famero de pixeles que est\u00e9n conectados y a su vez el primer LED recibir\u00e1 la informaci\u00f3n de todos los colores uno tras otro. La informaci\u00f3n se transmite de un LED a otro porque cuando un LED recibe 3 bytes nuevos de informaci\u00f3n entrega al siguiente LED los 3 bytes que conten\u00eda anteriormente, de esta manera cuando la placa con el programa termina de mandar todos los colores por el pin de datos el primer LED habr\u00eda recibido y enviado todos los colores para quedarse finalmente con el color que le corresponde y as\u00ed el resto de LEDs. De esta forma una tira de LEDs RGB direccionables es un dispositivo digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo.digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo. Conexi\u00f3n en cascada","title":"Aspectos previos"},{"location":"#aspectos-tecnicos","text":"Los LEDs RGB direccionables se suelen suministrar en tiras de diferentes longitudes y con distinto n\u00famero de LEDs y a veces se dispone la tira en forma de matriz. En la figura siguiente vemos el aspecto de algunos tipos. Tira y matriz de LEDs RGB Tienen 3 cables asociados a un conector y dos cables extra para a\u00f1adir alimentaci\u00f3n externa cuando es necesario porque la placa de control no entrega suficiente corriente para alimentar al conjunto. Cuando se trabaja con una tira de pocos LEDs no es necesario a\u00f1adir esta alimentaci\u00f3n externa, ya que placas como Arduino UNO o la ESP32 STEAMakers pueden suministrar la corriente que necesitan. En la figura siguiente vemos una tira de 8 LEDs: Tira de ocho LEDs RGB Cualquier tira de LEDs RGB (sea cual sea su disposici\u00f3n en l\u00ednea, como matriz, etc) debe utilizarse siempre en la direcci\u00f3n que marca el terminal hembra como entrada y el conector macho como salida. Las podemos ir conectando entre s\u00ed pero siempre respetando este sentido de la tira. Junto a cada led RGB est\u00e1 indicada la direcci\u00f3n de la tira mediante un tri\u00e1ngulo y tambi\u00e9n a qu\u00e9 pin debe ir conectado cada cable. Vemos +5V que corresponde a Vcc, GND, y en medio que pone Din o D0 que corresponde al pin digital de entrada de datos que debemos conectar al pin de salida de la placa de control. Tambi\u00e9n las podemos cortar por cualquiera de las l\u00edneas existentes entre cada uno de los LEDs y que est\u00e1 marcado con la l\u00ednea de corte. El corte debe hacerse dejando la mitad del pad de cobre a un lado y otro de la l\u00ednea y as\u00ed poder unir despu\u00e9s entre ellas con conectores especializados o sold\u00e1ndolas. Direcci\u00f3n y l\u00ednea de corte","title":"Aspectos t\u00e9cnicos"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Wikipedia Manuales de ArduinoBlocks Tutoriales para IDE 2 de Arduino","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Wikipedia Manuales de ArduinoBlocks Tutoriales para IDE 2 de Arduino","title":"Webgraf\u00eda y bibliograf\u00eda"},{"location":"temas/softAB/","text":"ArduinoBlocks \u00b6 Principalmente vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5.1 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5.1 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"ArduinoBlocks"},{"location":"temas/softAB/#arduinoblocks","text":"Principalmente vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5.1 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5.1 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"ArduinoBlocks"},{"location":"temas/softIDE/","text":"IDE 2 de Arduino \u00b6 Casi con toda seguridad que se nos va a presentar alguna ocasi\u00f3n en que ArduinoBlocks no satisfaga nuestras necesidades porque no exista el bloque en el momento que lo necesitamos. En estas ocasiones no nos va a quedar mas remedio que recurrir al Entorno de Desarrollo Integrado o IDE de Arduino. Antes de continuar indicar que aqu\u00ed vamos a describir como llevar a cabo los primeros pasos con el IDE 2.0 pero no vamos a tratar conceptos de programaci\u00f3n mediante c\u00f3digo. Vamos a describir como trabajar con el Arduino IDE 2.0 que ofrece mayor rendimiento, una interfaz de usuario mejorada y caracter\u00edsticas nuevas, como el autocompletado , un depurador incorporado y la sincronizaci\u00f3n de bocetos con Arduino Cloud. Todos los tutoriales del Arduino IDE 2 los tenemos en el enlace. C\u00f3digo en ArduinoBlocks \u00b6 La plataforma visual tambi\u00e9n nos ofrece algunas opciones para disponer del c\u00f3digo del programa y de las librer\u00edas que se utilizan, opciones que nos pueden resultar de utilidad en especial si no disponemos de bloques para continuar con nuestro programa. En la animaci\u00f3n de la figura siguiente vemos como ArduinoBlocks nos permite diferentes opciones de trabajo con el IDE, que son: Ver c\u00f3digo . Se despliega una ventana con el c\u00f3digo del programa actual cargado. Descargar c\u00f3digo (.ino) . Para exportar el c\u00f3digo para utilizarlo en Arduino IDE. ZIP project (.zip) . Para exportar el proyecto completo como .zip incluyendo librer\u00edas para Arduino IDE. Opciones de exportaci\u00f3n de ArduinoBlocks En el enlace a librer\u00edas podemos descargar el paquete que utiliza ArduinoBlocks e instalarlas todas o la que nos interese en el directorio de librer\u00edas de Arduino. Estas librer\u00edas nos ofrecen una ventaja adicional, y es que son librer\u00edas probadas y que funcionan correctamente. Descarga \u00b6 Podemos descargarlo desde la p\u00e1gina de software de Arduino IDE 2.0 y en el momento de creaci\u00f3n de este apartado de la web nos ofrece la versi\u00f3n 2.0.2 adem\u00e1s de los enlaces al editor online, tal y como vemos en la figura siguiente. Descargas En esta p\u00e1gina tenemos disponibles las versiones Nightly y otras informaciones importantes como: La versi\u00f3n de escritorio no est\u00e1 disponible para Chromebook donde deberemos trabajar con el editor web de Arduino . Es posible programar las placas utilizando MicroPython. En la p\u00e1gina MicroPython with Arduino tenemos toda la informaci\u00f3n. Opciones de descarga de versiones anteriores del IDE. T\u00e9rminos de servicio Si tenemos alguna duda podemos seguir el tutorial en ingl\u00e9s de descarga e instalaci\u00f3n de Arduino IDE 2.0 . Ventana principal del IDE 2.0 \u00b6 En la figura siguiente vemos el aspecto que presenta el IDE en la versi\u00f3n 2.0. Arduino IDE 2.0 A continuaci\u00f3n se describen de forma r\u00e1pida los apartados se\u00f1alados en la figura anterior. Verify/Upload (Verificar/Cargar): Para compilar y cargar el c\u00f3digo en la placa. Select board & port (Seleccionar placa y puerto): En el desplegable se muestran las placas detectadas de forma autom\u00e1tica, junto con el puerto asignado. Open Serial Plotter (abrir trazador ser\u00ede): Abre la herramienta de graficado como una nueva ventana. Open Serial Monitor (abrir el monitor serie): abre la herramienta Serial Monitor, como una nueva pesta\u00f1a en la consola. Sketchbook (Carpeta de programas): es el directorio o carpeta donde se almacenan localmente los programas. Adem\u00e1s, desde aqu\u00ed se puede sincronizar con Arduino Cloud y tambi\u00e9n obtener los sketch del entorno online. Boards Manager (Administrador de placas): para explorar los paquetes de Arduino y de terceros que se pueden instalar. Por ejemplo, usar una placa MKR WiFi 1010 requiere tener instalado el paquete Arduino SAMD Boards . Library Manager (Ad https://docs.arduino.cc/software/ide-v2./img/teo-basica/soft/ministrador de librer\u00edas): Para navegar por las librer\u00edas propias de Arduino y las creadas por la comunidad. Debugger (Depurador): Para probar y depurar programas en tiempo real. Search (Buscar): b\u00fasqueda de palabras en el c\u00f3digo. Caracter\u00edsticas principales del IDE 2.0 \u00b6 Ajustar preferencias \u00b6 En la animaci\u00f3n de la figura siguiente vemos como acceder a la configuraci\u00f3n de las mismas y tambi\u00e9n como se realiza alg\u00fan ajuste adicional. Preferencias IDE 2.0 La carpeta de programas \u00b6 Los programas o sketches de Arduino se guardan como .ino y deben almacenarse en una carpeta con el mismo nombre. Por ejemplo, un programa de nombre 'mi_programa.ino' debe almacenarse en una carpeta llamada 'mi_programa'. Generalmente se guardan en una carpeta de nombre 'Arduino' en la carpeta personal. En la animaci\u00f3n siguiente vemos como abrir y cerrar esta carpeta desde el bot\u00f3n de la barra lateral y como nos muestra el contenido Carpeta de programas Administrador de placas \u00b6 Con el Administrador de placas se pueden buscar e instalar paquetes o \"n\u00facleos\" para nuestras placas. Compilar y cargar un programa en una placa siempre requiere un paquete de la placa. Hay muchos paquetes de placa Arduino disponibles, como avr, samd, megaav y muchos m\u00e1s. basica Podemos decir que un \"n\u00facleo\" est\u00e1 escrito y dise\u00f1ado para microcontroladores espec\u00edficos y sabemos que las diferentes placas tienen micros de diferentes tipos. Por ejemplo, un Arduino UNO tiene un ATmega328P , que usa el n\u00facleo AVR , mientras que un Arduino Nano 33 IoT tiene un microcontrolador SAMD21 , donde necesitamos usar el n\u00facleo SAMD . En definitiva, para poder usar una placa concreta debemos instalar su n\u00facleo espec\u00edfico. Al hacer clic en el bot\u00f3n de la barra lateral se nos abren todas las opciones disponibles y ne indica si est\u00e1n o no instalados y adem\u00e1s dispone de un buscador que permite localizar el n\u00facleo que necesitamos. Hay que tener presente que la instalaci\u00f3n de algunos de ellos puede tardar varios minutos. En la animaci\u00f3n vemos el funcionamiento de este bot\u00f3n. Administrador de placas Gestor de librer\u00edas \u00b6 Este bot\u00f3n nos permite buscar e instalar librer\u00edas, que son extensiones de la API de Arduino que facilitan el control de un servo, leer un sensor espec\u00edfico o utilizar un m\u00f3dulo WiFi. En la animaci\u00f3n vemos como utilizar este bot\u00f3n. Gestor de librer\u00edas Monitor serie \u00b6 Esta herramienta que habitualmente estaba en una ventana separada ahora se integra en el editor. La herramienta sirve para comunicarse con la placa o para depurar programas. Una ventaja de tener el Serial Monitor integrado con el editor es la posibilidad de tener m\u00faltiples monitores abiertos simult\u00e1neamente. En el editor antiguo, al cambiar el puerto/placa, cambiaba en todas las ventanas. Adem\u00e1s, est\u00e1bamos limitados a una ventana de Serial Monitor, un obst\u00e1culo que el IDE 2.0 elimina. En la animaci\u00f3n vemos el uso b\u00e1sico del mismo. Monitor serie basica Para obtener m\u00e1s informaci\u00f3n sobre Serial Monitor podemos visitar el Serial Monitor tutorial . Serial Plotter \u00b6 Nos permite visualizar datos utilizando gr\u00e1ficos permitiendo monitorizar varias variables de manera simultanea. Para ver mejor el funcionamiento de este elemento vamos a utilizar el potenci\u00f3metro de la autocaravana (A3) junto con una variable est\u00e1tica y una aleatoria. El c\u00f3digo del ejemplo es: int potenciometro; int aleatoria; int static_variable = 500; void setup() { Serial.begin(9600); } void loop() { potenciometro = analogRead(A3); aleatoria = random(0, 1000); Serial.print(\"Potenciometro:\"); Serial.print(potenciometro); Serial.print(\",\"); Serial.print(\"Vlor aleatorio:\"); Serial.print(aleatoria); Serial.print(\",\"); Serial.print(\"Variable estatica:\"); Serial.println(static_variable); } En la animaci\u00f3n vemos como cargar el programa y el funcionamiento en la ventana del Serial Plotter. Serial Plotter Debugger \u00b6 El depurador se utiliza para probar y depurar programas. B\u00e1sicamente lo que permite es navegar a trav\u00e9s de la ejecuci\u00f3n de un programa, lo que sirve para detectar fallos o errores de c\u00f3digo. El depurador solamente est\u00e1 disponible con las placas SAMD. Tenemos mas informaci\u00f3n en Debugging tutorial . Autocompletado \u00b6 Es una nueva caracter\u00edstica de la versi\u00f3n 2.0 muy bien equipada. Debemos tener presente que para que funcione debemos tener seleccionada la placa a utilizar. En la animaci\u00f3n siguiente vemos la herramienta funcionando. Autocompletado","title":"IDE 2"},{"location":"temas/softIDE/#ide-2-de-arduino","text":"Casi con toda seguridad que se nos va a presentar alguna ocasi\u00f3n en que ArduinoBlocks no satisfaga nuestras necesidades porque no exista el bloque en el momento que lo necesitamos. En estas ocasiones no nos va a quedar mas remedio que recurrir al Entorno de Desarrollo Integrado o IDE de Arduino. Antes de continuar indicar que aqu\u00ed vamos a describir como llevar a cabo los primeros pasos con el IDE 2.0 pero no vamos a tratar conceptos de programaci\u00f3n mediante c\u00f3digo. Vamos a describir como trabajar con el Arduino IDE 2.0 que ofrece mayor rendimiento, una interfaz de usuario mejorada y caracter\u00edsticas nuevas, como el autocompletado , un depurador incorporado y la sincronizaci\u00f3n de bocetos con Arduino Cloud. Todos los tutoriales del Arduino IDE 2 los tenemos en el enlace.","title":"IDE 2 de Arduino"},{"location":"temas/softIDE/#codigo-en-arduinoblocks","text":"La plataforma visual tambi\u00e9n nos ofrece algunas opciones para disponer del c\u00f3digo del programa y de las librer\u00edas que se utilizan, opciones que nos pueden resultar de utilidad en especial si no disponemos de bloques para continuar con nuestro programa. En la animaci\u00f3n de la figura siguiente vemos como ArduinoBlocks nos permite diferentes opciones de trabajo con el IDE, que son: Ver c\u00f3digo . Se despliega una ventana con el c\u00f3digo del programa actual cargado. Descargar c\u00f3digo (.ino) . Para exportar el c\u00f3digo para utilizarlo en Arduino IDE. ZIP project (.zip) . Para exportar el proyecto completo como .zip incluyendo librer\u00edas para Arduino IDE. Opciones de exportaci\u00f3n de ArduinoBlocks En el enlace a librer\u00edas podemos descargar el paquete que utiliza ArduinoBlocks e instalarlas todas o la que nos interese en el directorio de librer\u00edas de Arduino. Estas librer\u00edas nos ofrecen una ventaja adicional, y es que son librer\u00edas probadas y que funcionan correctamente.","title":"C\u00f3digo en ArduinoBlocks"},{"location":"temas/softIDE/#descarga","text":"Podemos descargarlo desde la p\u00e1gina de software de Arduino IDE 2.0 y en el momento de creaci\u00f3n de este apartado de la web nos ofrece la versi\u00f3n 2.0.2 adem\u00e1s de los enlaces al editor online, tal y como vemos en la figura siguiente. Descargas En esta p\u00e1gina tenemos disponibles las versiones Nightly y otras informaciones importantes como: La versi\u00f3n de escritorio no est\u00e1 disponible para Chromebook donde deberemos trabajar con el editor web de Arduino . Es posible programar las placas utilizando MicroPython. En la p\u00e1gina MicroPython with Arduino tenemos toda la informaci\u00f3n. Opciones de descarga de versiones anteriores del IDE. T\u00e9rminos de servicio Si tenemos alguna duda podemos seguir el tutorial en ingl\u00e9s de descarga e instalaci\u00f3n de Arduino IDE 2.0 .","title":"Descarga"},{"location":"temas/softIDE/#ventana-principal-del-ide-20","text":"En la figura siguiente vemos el aspecto que presenta el IDE en la versi\u00f3n 2.0. Arduino IDE 2.0 A continuaci\u00f3n se describen de forma r\u00e1pida los apartados se\u00f1alados en la figura anterior. Verify/Upload (Verificar/Cargar): Para compilar y cargar el c\u00f3digo en la placa. Select board & port (Seleccionar placa y puerto): En el desplegable se muestran las placas detectadas de forma autom\u00e1tica, junto con el puerto asignado. Open Serial Plotter (abrir trazador ser\u00ede): Abre la herramienta de graficado como una nueva ventana. Open Serial Monitor (abrir el monitor serie): abre la herramienta Serial Monitor, como una nueva pesta\u00f1a en la consola. Sketchbook (Carpeta de programas): es el directorio o carpeta donde se almacenan localmente los programas. Adem\u00e1s, desde aqu\u00ed se puede sincronizar con Arduino Cloud y tambi\u00e9n obtener los sketch del entorno online. Boards Manager (Administrador de placas): para explorar los paquetes de Arduino y de terceros que se pueden instalar. Por ejemplo, usar una placa MKR WiFi 1010 requiere tener instalado el paquete Arduino SAMD Boards . Library Manager (Ad https://docs.arduino.cc/software/ide-v2./img/teo-basica/soft/ministrador de librer\u00edas): Para navegar por las librer\u00edas propias de Arduino y las creadas por la comunidad. Debugger (Depurador): Para probar y depurar programas en tiempo real. Search (Buscar): b\u00fasqueda de palabras en el c\u00f3digo.","title":"Ventana principal del IDE 2.0"},{"location":"temas/softIDE/#caracteristicas-principales-del-ide-20","text":"","title":"Caracter\u00edsticas principales del IDE 2.0"},{"location":"temas/softIDE/#ajustar-preferencias","text":"En la animaci\u00f3n de la figura siguiente vemos como acceder a la configuraci\u00f3n de las mismas y tambi\u00e9n como se realiza alg\u00fan ajuste adicional. Preferencias IDE 2.0","title":"Ajustar preferencias"},{"location":"temas/softIDE/#la-carpeta-de-programas","text":"Los programas o sketches de Arduino se guardan como .ino y deben almacenarse en una carpeta con el mismo nombre. Por ejemplo, un programa de nombre 'mi_programa.ino' debe almacenarse en una carpeta llamada 'mi_programa'. Generalmente se guardan en una carpeta de nombre 'Arduino' en la carpeta personal. En la animaci\u00f3n siguiente vemos como abrir y cerrar esta carpeta desde el bot\u00f3n de la barra lateral y como nos muestra el contenido Carpeta de programas","title":"La carpeta de programas"},{"location":"temas/softIDE/#administrador-de-placas","text":"Con el Administrador de placas se pueden buscar e instalar paquetes o \"n\u00facleos\" para nuestras placas. Compilar y cargar un programa en una placa siempre requiere un paquete de la placa. Hay muchos paquetes de placa Arduino disponibles, como avr, samd, megaav y muchos m\u00e1s. basica Podemos decir que un \"n\u00facleo\" est\u00e1 escrito y dise\u00f1ado para microcontroladores espec\u00edficos y sabemos que las diferentes placas tienen micros de diferentes tipos. Por ejemplo, un Arduino UNO tiene un ATmega328P , que usa el n\u00facleo AVR , mientras que un Arduino Nano 33 IoT tiene un microcontrolador SAMD21 , donde necesitamos usar el n\u00facleo SAMD . En definitiva, para poder usar una placa concreta debemos instalar su n\u00facleo espec\u00edfico. Al hacer clic en el bot\u00f3n de la barra lateral se nos abren todas las opciones disponibles y ne indica si est\u00e1n o no instalados y adem\u00e1s dispone de un buscador que permite localizar el n\u00facleo que necesitamos. Hay que tener presente que la instalaci\u00f3n de algunos de ellos puede tardar varios minutos. En la animaci\u00f3n vemos el funcionamiento de este bot\u00f3n. Administrador de placas","title":"Administrador de placas"},{"location":"temas/softIDE/#gestor-de-librerias","text":"Este bot\u00f3n nos permite buscar e instalar librer\u00edas, que son extensiones de la API de Arduino que facilitan el control de un servo, leer un sensor espec\u00edfico o utilizar un m\u00f3dulo WiFi. En la animaci\u00f3n vemos como utilizar este bot\u00f3n. Gestor de librer\u00edas","title":"Gestor de librer\u00edas"},{"location":"temas/softIDE/#monitor-serie","text":"Esta herramienta que habitualmente estaba en una ventana separada ahora se integra en el editor. La herramienta sirve para comunicarse con la placa o para depurar programas. Una ventaja de tener el Serial Monitor integrado con el editor es la posibilidad de tener m\u00faltiples monitores abiertos simult\u00e1neamente. En el editor antiguo, al cambiar el puerto/placa, cambiaba en todas las ventanas. Adem\u00e1s, est\u00e1bamos limitados a una ventana de Serial Monitor, un obst\u00e1culo que el IDE 2.0 elimina. En la animaci\u00f3n vemos el uso b\u00e1sico del mismo. Monitor serie basica Para obtener m\u00e1s informaci\u00f3n sobre Serial Monitor podemos visitar el Serial Monitor tutorial .","title":"Monitor serie"},{"location":"temas/softIDE/#serial-plotter","text":"Nos permite visualizar datos utilizando gr\u00e1ficos permitiendo monitorizar varias variables de manera simultanea. Para ver mejor el funcionamiento de este elemento vamos a utilizar el potenci\u00f3metro de la autocaravana (A3) junto con una variable est\u00e1tica y una aleatoria. El c\u00f3digo del ejemplo es: int potenciometro; int aleatoria; int static_variable = 500; void setup() { Serial.begin(9600); } void loop() { potenciometro = analogRead(A3); aleatoria = random(0, 1000); Serial.print(\"Potenciometro:\"); Serial.print(potenciometro); Serial.print(\",\"); Serial.print(\"Vlor aleatorio:\"); Serial.print(aleatoria); Serial.print(\",\"); Serial.print(\"Variable estatica:\"); Serial.println(static_variable); } En la animaci\u00f3n vemos como cargar el programa y el funcionamiento en la ventana del Serial Plotter. Serial Plotter","title":"Serial Plotter"},{"location":"temas/softIDE/#debugger","text":"El depurador se utiliza para probar y depurar programas. B\u00e1sicamente lo que permite es navegar a trav\u00e9s de la ejecuci\u00f3n de un programa, lo que sirve para detectar fallos o errores de c\u00f3digo. El depurador solamente est\u00e1 disponible con las placas SAMD. Tenemos mas informaci\u00f3n en Debugging tutorial .","title":"Debugger"},{"location":"temas/softIDE/#autocompletado","text":"Es una nueva caracter\u00edstica de la versi\u00f3n 2.0 muy bien equipada. Debemos tener presente que para que funcione debemos tener seleccionada la placa a utilizar. En la animaci\u00f3n siguiente vemos la herramienta funcionando. Autocompletado","title":"Autocompletado"}]}