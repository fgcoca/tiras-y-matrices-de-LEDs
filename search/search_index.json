{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tiras y matrices de LEDs \u00b6 B\u00e1sicamente vamos a dar unas notas sobre algunos de estos elementos. El tema ser\u00e1 tratado tanto desde el entorno gr\u00e1fico de ArduinoBlocks como desde el IDE de Arduino. Las placas controladoras que m\u00e1s utilizar\u00e9 son las de las figuras siguientes, o similares. Placa tipo que se utilizan Diodo LED \u00b6 El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz cuando se polariza directamente, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la figura siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores Matriz de 8x8 LEDs \u00b6 Es una pantalla o distribuci\u00f3n de 8x8 LEDs en la que podemos programar diferentes s\u00edmbolos o elementos, como: caras, iconos, letras... Hay opciones predise\u00f1adas desde ArduinoBlocks y tambi\u00e9n, existe la opci\u00f3n de crearlos personalizados. Se trata de dispositivos I2C y su aspecto, cuando no podemos cambiar su direcci\u00f3n f\u00edsica, es el de la figura siguiente. Aspecto de la matriz de 8x8 Este tipo de matrices son 'multiplexadas', por lo que para controlar 64 LED necesitamos 16 pines y eso son muchos pines aunque hay chips de controladores como el MAX7219 que pueden controlar una matriz, pero a\u00fan as\u00ed hay mucho cableado que configurar y ocupan muchos pines. Para solucionar esto se utiliza un chip de control que tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s del m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El conjunto forma una matriz de 8x8 que se controla a trav\u00e9s de una interfaz I2C. Sus principales caracter\u00edsticas son: Matriz de LEDs de 8 filas y 8 columnas Direccionada por un chip HT16K33 Conexi\u00f3n tipo I2C Tensi\u00f3n de alimentaci\u00f3n: 5V Frecuencia de trabajo: 400KHz Potencia de entrada: 2.5W Corriente de entrada: 500mA Tambi\u00e9n existen matrices que son direccionables , como la que vemos en la imagen siguiente: Aspecto de la matriz de 8x8 direccionable LED RGB y matrices RGB \u00b6 Un LED RGB es en realidad un encapsulado que incorpora tled rgbres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. Colores RGB Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB. El s\u00edmbolo y la representaci\u00f3n mas comunes de este componente lo vemos en la imagen siguiente: S\u00edmbolo y representaci\u00f3n LED RGB El aspecto del componente en sus versiones inserci\u00f3n y SMD lo vemos en la imagen siguiente: Aspecto LED RGB Estos LEDs se pueden agrupar en forma de matrices de diferentes n\u00fameros de LEDs ordenados por filas y columnas. En la figura siguiente vemos una muestra de este tipo de matrices. Matrices de LED RGB La fila inferior corresponde a elemento normalmente utilizados en iluminaci\u00f3n profesional y espect\u00e1culos que se controlan mediante dispositivos DMX y que suelen tener potencias elevadas. LED RGB direccionable \u00b6 Com\u00fanmente se les conoce como Neopixel, que es una marca registrada por Adafruit Industries . Cada LED que componen la tira o matriz tiene los siguientes cuatro pines: Alimentaci\u00f3n VDD: 5V Tierra: GND DI (Date Input): pin para recibir informaci\u00f3n DO (Date Output): pin para enviar inforamci\u00f3n Cada uno de los LEDs es direccionable de manera individual gracias al circuito electr\u00f3nico que incluyen que es un circuito l\u00f3gico con una memoria de un byte por color. Los tipos mas comunes son el SK6812, WS2811 o, el mas habitual de todos, el WS2812 cuyo datasheet tenemos en el enlace. El WS2812B incluye un oscilador interno de precisi\u00f3n y un circuito de control de corriente constante programable de 12 V, lo que garantiza de manera efectiva que la intensidad del color sea consistente. El protocolo de transferencia de datos utiliza un \u00fanico modo de comunicaci\u00f3n de multiplexado NZR. En la figura siguiente vemos el aspecto de un diodo LED RGB individual en formato inserci\u00f3n y SMD. Aspecto de un diodo LED RGB direccionable Aspectos previos \u00b6 Para transmitir informaci\u00f3n digital esta se debe sincronizar mediante una convenci\u00f3n especial, la codificaci\u00f3n. Dos dispositivos llevan una comunicaci\u00f3n por cable convirtiendo la informaci\u00f3n a transmitir en un flujo de bits (0 y 1) o \"Dates\" que se suele nombrar con la letra D y que va acompa\u00f1ada de una se\u00f1al de reloj para sincronizar las transmisiones. La forma convencional de transmisi\u00f3n digital se componen de una l\u00ednea de datos mas una l\u00ednea de reloj. Ahora bien, cualquier ligera desviaci\u00f3n en la longitud de estas l\u00edneas har\u00e1 que el receptor no cumpla con el tiempo de establecimiento del muestreo de datos, originando errores en los datos. La forma de asegurar que esas l\u00edneas son id\u00e9nticas es que sean la misma l\u00ednea, lo que hace que aparezcan c\u00f3digos que fusionan los datos y el reloj, entre los que est\u00e1n los c\u00f3digo RZ, NRZ y NRZI que vamos a ver someramente a continuaci\u00f3n. Codificaci\u00f3n RZ . El acr\u00f3nimo de de \"Return Zero\" o retorno cero y su caracter\u00edstica es que se transmiten bits de datos dentro de cada periodo de la se\u00f1al. En la figura siguiente los datos se representan en rojo y vemos que ocupan una parte del periodo T, siendo y matrices RGBcero el resto del tiempo. Este sistema se denomina RZ unipolar o retorno a cero unipolar y como se observa en la figura un nivel bajo indica 0 y un nivel positivo indica 1. C\u00f3digo RZ unipolar El c\u00f3digo de retorno a cero se divide en un c\u00f3digo de retorno a cero unipolar y un c\u00f3digo de retorno a cero bipolar en el que el nivel alto indica 1 y el nivel negativo o, tal y como vemos en la figura siguiente: C\u00f3digo RZ bipolar Codificaci\u00f3n NRZ . El acr\u00f3nimo es de \"Not Return Zero\" o c\u00f3digo sin retorno a cero y se diferencia del RZ en que no necesita retornar a cero. En la figura siguiente vemos gr\u00e1ficamente el c\u00f3digo. C\u00f3digo NRZ En el datasheet estos c\u00f3digo se denominan T0H y T0L. El funcionamiento de una agrupaci\u00f3n en cascada como la de la figura siguiente se puede resumir diciendo que: el circuito integrado de cada LED puede almacenar 3 bytes (24 bits), un byte para cada color. Solo el primer LED est\u00e1 conectado al Pin de control, en este caso, un pin digital de nuestra placa, que enviar\u00e1 la cadena de todos los colores seg\u00fan el n\u00famero de pixeles que est\u00e9n conectados y a su vez el primer LED recibir\u00e1 la informaci\u00f3n de todos los colores uno tras otro. La informaci\u00f3n se transmite de un LED a otro porque cuando un LED recibe 3 bytes nuevos de informaci\u00f3n entrega al siguiente LED los 3 bytes que conten\u00eda anteriormente, de esta manera cuando la placa con el programa termina de mandar todos los colores por el pin de datos el primer LED habr\u00eda recibido y enviado todos los colores para quedarse finalmente con el color que le corresponde y as\u00ed el resto de LEDs. De esta forma una tira de LEDs RGB direccionables es un dispositivo digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo.digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo. Conexi\u00f3n en cascada Aspectos t\u00e9cnicos \u00b6 Los LEDs RGB direccionables se suelen suministrar en tiras de diferentes longitudes y con distinto n\u00famero de LEDs y a veces se dispone la tira en forma de matriz. En la figura siguiente vemos el aspecto de algunos tipos. Tira y matriz de LEDs RGB Tienen 3 cables asociados a un conector y dos cables extra para a\u00f1adir alimentaci\u00f3n externa cuando es necesario porque la placa de control no entrega suficiente corriente para alimentar al conjunto. Cuando se trabaja con una tira de pocos LEDs no es necesario a\u00f1adir esta alimentaci\u00f3n externa, ya que placas como Arduino UNO o la ESP32 STEAMakers pueden suministrar la corriente que necesitan. En la figura siguiente vemos una tira de 8 LEDs: Tira de ocho LEDs RGB Cualquier tira de LEDs RGB (sea cual sea su disposici\u00f3n en l\u00ednea, como matriz, etc) debe utilizarse siempre en la direcci\u00f3n que marca el terminal hembra como entrada y el conector macho como salida. Las podemos ir conectando entre s\u00ed pero siempre respetando este sentido de la tira. Junto a cada led RGB est\u00e1 indicada la direcci\u00f3n de la tira mediante un tri\u00e1ngulo y tambi\u00e9n a qu\u00e9 pin debe ir conectado cada cable. Vemos +5V que corresponde a Vcc, GND, y en medio que pone Din o D0 que corresponde al pin digital de entrada de datos que debemos conectar al pin de salida de la placa de control. Tambi\u00e9n las podemos cortar por cualquiera de las l\u00edneas existentes entre cada uno de los LEDs y que est\u00e1 marcado con la l\u00ednea de corte. El corte debe hacerse dejando la mitad del pad de cobre a un lado y otro de la l\u00ednea y as\u00ed poder unir despu\u00e9s entre ellas con conectores especializados o sold\u00e1ndolas. Direcci\u00f3n y l\u00ednea de corte","title":"Introducci\u00f3n"},{"location":"#tiras-y-matrices-de-leds","text":"B\u00e1sicamente vamos a dar unas notas sobre algunos de estos elementos. El tema ser\u00e1 tratado tanto desde el entorno gr\u00e1fico de ArduinoBlocks como desde el IDE de Arduino. Las placas controladoras que m\u00e1s utilizar\u00e9 son las de las figuras siguientes, o similares. Placa tipo que se utilizan","title":"Tiras y matrices de LEDs"},{"location":"#diodo-led","text":"El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz cuando se polariza directamente, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la figura siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores","title":"Diodo LED"},{"location":"#matriz-de-8x8-leds","text":"Es una pantalla o distribuci\u00f3n de 8x8 LEDs en la que podemos programar diferentes s\u00edmbolos o elementos, como: caras, iconos, letras... Hay opciones predise\u00f1adas desde ArduinoBlocks y tambi\u00e9n, existe la opci\u00f3n de crearlos personalizados. Se trata de dispositivos I2C y su aspecto, cuando no podemos cambiar su direcci\u00f3n f\u00edsica, es el de la figura siguiente. Aspecto de la matriz de 8x8 Este tipo de matrices son 'multiplexadas', por lo que para controlar 64 LED necesitamos 16 pines y eso son muchos pines aunque hay chips de controladores como el MAX7219 que pueden controlar una matriz, pero a\u00fan as\u00ed hay mucho cableado que configurar y ocupan muchos pines. Para solucionar esto se utiliza un chip de control que tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s del m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El conjunto forma una matriz de 8x8 que se controla a trav\u00e9s de una interfaz I2C. Sus principales caracter\u00edsticas son: Matriz de LEDs de 8 filas y 8 columnas Direccionada por un chip HT16K33 Conexi\u00f3n tipo I2C Tensi\u00f3n de alimentaci\u00f3n: 5V Frecuencia de trabajo: 400KHz Potencia de entrada: 2.5W Corriente de entrada: 500mA Tambi\u00e9n existen matrices que son direccionables , como la que vemos en la imagen siguiente: Aspecto de la matriz de 8x8 direccionable","title":"Matriz de 8x8 LEDs"},{"location":"#led-rgb-y-matrices-rgb","text":"Un LED RGB es en realidad un encapsulado que incorpora tled rgbres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. Colores RGB Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB. El s\u00edmbolo y la representaci\u00f3n mas comunes de este componente lo vemos en la imagen siguiente: S\u00edmbolo y representaci\u00f3n LED RGB El aspecto del componente en sus versiones inserci\u00f3n y SMD lo vemos en la imagen siguiente: Aspecto LED RGB Estos LEDs se pueden agrupar en forma de matrices de diferentes n\u00fameros de LEDs ordenados por filas y columnas. En la figura siguiente vemos una muestra de este tipo de matrices. Matrices de LED RGB La fila inferior corresponde a elemento normalmente utilizados en iluminaci\u00f3n profesional y espect\u00e1culos que se controlan mediante dispositivos DMX y que suelen tener potencias elevadas.","title":"LED RGB y matrices RGB"},{"location":"#led-rgb-direccionable","text":"Com\u00fanmente se les conoce como Neopixel, que es una marca registrada por Adafruit Industries . Cada LED que componen la tira o matriz tiene los siguientes cuatro pines: Alimentaci\u00f3n VDD: 5V Tierra: GND DI (Date Input): pin para recibir informaci\u00f3n DO (Date Output): pin para enviar inforamci\u00f3n Cada uno de los LEDs es direccionable de manera individual gracias al circuito electr\u00f3nico que incluyen que es un circuito l\u00f3gico con una memoria de un byte por color. Los tipos mas comunes son el SK6812, WS2811 o, el mas habitual de todos, el WS2812 cuyo datasheet tenemos en el enlace. El WS2812B incluye un oscilador interno de precisi\u00f3n y un circuito de control de corriente constante programable de 12 V, lo que garantiza de manera efectiva que la intensidad del color sea consistente. El protocolo de transferencia de datos utiliza un \u00fanico modo de comunicaci\u00f3n de multiplexado NZR. En la figura siguiente vemos el aspecto de un diodo LED RGB individual en formato inserci\u00f3n y SMD. Aspecto de un diodo LED RGB direccionable","title":"LED RGB direccionable"},{"location":"#aspectos-previos","text":"Para transmitir informaci\u00f3n digital esta se debe sincronizar mediante una convenci\u00f3n especial, la codificaci\u00f3n. Dos dispositivos llevan una comunicaci\u00f3n por cable convirtiendo la informaci\u00f3n a transmitir en un flujo de bits (0 y 1) o \"Dates\" que se suele nombrar con la letra D y que va acompa\u00f1ada de una se\u00f1al de reloj para sincronizar las transmisiones. La forma convencional de transmisi\u00f3n digital se componen de una l\u00ednea de datos mas una l\u00ednea de reloj. Ahora bien, cualquier ligera desviaci\u00f3n en la longitud de estas l\u00edneas har\u00e1 que el receptor no cumpla con el tiempo de establecimiento del muestreo de datos, originando errores en los datos. La forma de asegurar que esas l\u00edneas son id\u00e9nticas es que sean la misma l\u00ednea, lo que hace que aparezcan c\u00f3digos que fusionan los datos y el reloj, entre los que est\u00e1n los c\u00f3digo RZ, NRZ y NRZI que vamos a ver someramente a continuaci\u00f3n. Codificaci\u00f3n RZ . El acr\u00f3nimo de de \"Return Zero\" o retorno cero y su caracter\u00edstica es que se transmiten bits de datos dentro de cada periodo de la se\u00f1al. En la figura siguiente los datos se representan en rojo y vemos que ocupan una parte del periodo T, siendo y matrices RGBcero el resto del tiempo. Este sistema se denomina RZ unipolar o retorno a cero unipolar y como se observa en la figura un nivel bajo indica 0 y un nivel positivo indica 1. C\u00f3digo RZ unipolar El c\u00f3digo de retorno a cero se divide en un c\u00f3digo de retorno a cero unipolar y un c\u00f3digo de retorno a cero bipolar en el que el nivel alto indica 1 y el nivel negativo o, tal y como vemos en la figura siguiente: C\u00f3digo RZ bipolar Codificaci\u00f3n NRZ . El acr\u00f3nimo es de \"Not Return Zero\" o c\u00f3digo sin retorno a cero y se diferencia del RZ en que no necesita retornar a cero. En la figura siguiente vemos gr\u00e1ficamente el c\u00f3digo. C\u00f3digo NRZ En el datasheet estos c\u00f3digo se denominan T0H y T0L. El funcionamiento de una agrupaci\u00f3n en cascada como la de la figura siguiente se puede resumir diciendo que: el circuito integrado de cada LED puede almacenar 3 bytes (24 bits), un byte para cada color. Solo el primer LED est\u00e1 conectado al Pin de control, en este caso, un pin digital de nuestra placa, que enviar\u00e1 la cadena de todos los colores seg\u00fan el n\u00famero de pixeles que est\u00e9n conectados y a su vez el primer LED recibir\u00e1 la informaci\u00f3n de todos los colores uno tras otro. La informaci\u00f3n se transmite de un LED a otro porque cuando un LED recibe 3 bytes nuevos de informaci\u00f3n entrega al siguiente LED los 3 bytes que conten\u00eda anteriormente, de esta manera cuando la placa con el programa termina de mandar todos los colores por el pin de datos el primer LED habr\u00eda recibido y enviado todos los colores para quedarse finalmente con el color que le corresponde y as\u00ed el resto de LEDs. De esta forma una tira de LEDs RGB direccionables es un dispositivo digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo.digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo. Conexi\u00f3n en cascada","title":"Aspectos previos"},{"location":"#aspectos-tecnicos","text":"Los LEDs RGB direccionables se suelen suministrar en tiras de diferentes longitudes y con distinto n\u00famero de LEDs y a veces se dispone la tira en forma de matriz. En la figura siguiente vemos el aspecto de algunos tipos. Tira y matriz de LEDs RGB Tienen 3 cables asociados a un conector y dos cables extra para a\u00f1adir alimentaci\u00f3n externa cuando es necesario porque la placa de control no entrega suficiente corriente para alimentar al conjunto. Cuando se trabaja con una tira de pocos LEDs no es necesario a\u00f1adir esta alimentaci\u00f3n externa, ya que placas como Arduino UNO o la ESP32 STEAMakers pueden suministrar la corriente que necesitan. En la figura siguiente vemos una tira de 8 LEDs: Tira de ocho LEDs RGB Cualquier tira de LEDs RGB (sea cual sea su disposici\u00f3n en l\u00ednea, como matriz, etc) debe utilizarse siempre en la direcci\u00f3n que marca el terminal hembra como entrada y el conector macho como salida. Las podemos ir conectando entre s\u00ed pero siempre respetando este sentido de la tira. Junto a cada led RGB est\u00e1 indicada la direcci\u00f3n de la tira mediante un tri\u00e1ngulo y tambi\u00e9n a qu\u00e9 pin debe ir conectado cada cable. Vemos +5V que corresponde a Vcc, GND, y en medio que pone Din o D0 que corresponde al pin digital de entrada de datos que debemos conectar al pin de salida de la placa de control. Tambi\u00e9n las podemos cortar por cualquiera de las l\u00edneas existentes entre cada uno de los LEDs y que est\u00e1 marcado con la l\u00ednea de corte. El corte debe hacerse dejando la mitad del pad de cobre a un lado y otro de la l\u00ednea y as\u00ed poder unir despu\u00e9s entre ellas con conectores especializados o sold\u00e1ndolas. Direcci\u00f3n y l\u00ednea de corte","title":"Aspectos t\u00e9cnicos"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Wikipedia Manuales de ArduinoBlocks Tutoriales para IDE 2 de Arduino Adafruit NeoPixel \u00dcberguide FastLED Animation Library by Daniel Garcia focalintent .","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Wikipedia Manuales de ArduinoBlocks Tutoriales para IDE 2 de Arduino Adafruit NeoPixel \u00dcberguide FastLED Animation Library by Daniel Garcia focalintent .","title":"Webgraf\u00eda y bibliograf\u00eda"},{"location":"temas/3d/","text":"Archivos para impresi\u00f3n 3D \u00b6 El dise\u00f1o de las cajas para soporte de los elementos est\u00e1n inspirados en los siguientes modelos: Caja para la matriz de 16x16 De Printables , el modelo 3D LED Matrix 16x16 - ESP8266 / Arduino - NeoPixel / WS2812b . En Thingiverse tenemos el mismo modelo LED Matrix 16x16 - ESP8266 / Arduino - NeoPixel / WS2812b Caja para el jpoystick En Thingiverse tenemos el modelo Box for joystick module Arduino Elegoo A continuaci\u00f3n tenemos el listado de archivos .stl junto con su descripci\u00f3n. Archivo Descripci\u00f3n Base matriz Base principal para el resto de elementos 3D de la matriz de LEDs de 16x16 Soporte Elemento de separaci\u00f3n para alojar cables y componentes y servir de soporte a la matriz Rejilla Una rejilla de 16x16 que separa los LEDs unos de otros Tapa La tapadera del conjunto de elementos anteriores Base joystick Soporte para alojar el dispositivo junto al cable de conexi\u00f3n Caja jpystick Elemento de cierre de la base Flechas Elemento decorativo indicativo de la direcci\u00f3n del movimiento. La 'C' del centro indica que con el pulsador se puede cambiar el color de la serpiente En la animaci\u00f3n siguiente vemos el aspecto de estos elementos y la secuencia de montaje de los mismos. Partes de la caja de la rejilla En la siguiente tenemos lo mismo pero para el joystick. Partes de la caja del joystick","title":"3D"},{"location":"temas/3d/#archivos-para-impresion-3d","text":"El dise\u00f1o de las cajas para soporte de los elementos est\u00e1n inspirados en los siguientes modelos: Caja para la matriz de 16x16 De Printables , el modelo 3D LED Matrix 16x16 - ESP8266 / Arduino - NeoPixel / WS2812b . En Thingiverse tenemos el mismo modelo LED Matrix 16x16 - ESP8266 / Arduino - NeoPixel / WS2812b Caja para el jpoystick En Thingiverse tenemos el modelo Box for joystick module Arduino Elegoo A continuaci\u00f3n tenemos el listado de archivos .stl junto con su descripci\u00f3n. Archivo Descripci\u00f3n Base matriz Base principal para el resto de elementos 3D de la matriz de LEDs de 16x16 Soporte Elemento de separaci\u00f3n para alojar cables y componentes y servir de soporte a la matriz Rejilla Una rejilla de 16x16 que separa los LEDs unos de otros Tapa La tapadera del conjunto de elementos anteriores Base joystick Soporte para alojar el dispositivo junto al cable de conexi\u00f3n Caja jpystick Elemento de cierre de la base Flechas Elemento decorativo indicativo de la direcci\u00f3n del movimiento. La 'C' del centro indica que con el pulsador se puede cambiar el color de la serpiente En la animaci\u00f3n siguiente vemos el aspecto de estos elementos y la secuencia de montaje de los mismos. Partes de la caja de la rejilla En la siguiente tenemos lo mismo pero para el joystick. Partes de la caja del joystick","title":"Archivos para impresi\u00f3n 3D"},{"location":"temas/LED8x8/","text":"Matrices de 8x8 LEDs \u00b6 Fundamentalmente, aunque su aspecto exterior es id\u00e9ntico, vamos a distinguir dos tipos: Matriz de 8x8 LEDs sin controlador Matrices I2C controladas por el chip HT16K33 como las que se contemplan en ArduinoBlocks. Matrices controladas por el chip MAX7219 o MAX7221 que se controlan con la librer\u00eda MD_MAX72xx Matriz de 8x8 LEDs \u00b6 Se trata simplemente de diodos LED dispuestos en forma de matriz de 8x8 en los que se han unido por filas todos los c\u00e1todos o todos los \u00e1nodos de los diodos y se ha hecho lo propio con la otra patilla de cada columna. Esto da lugar a los dos tipos posibles de matrices, de \u00e1nodo com\u00fan o de c\u00e1todo com\u00fan. En la figura siguiente vemos el aspecto externo de estos elementos y los diagramas de conexi\u00f3n interna de cada tipo. Aspecto y diagramas de conexi\u00f3n interna La m\u00e1s com\u00fan dentro del mundo Arduino es la de c\u00e1todo com\u00fan para excitar los pines con niveles altos. En total una matriz de este tipo dispone de 16 patillas para controlar los 64 LEDs por lo que es evidente que no se pueden controlar los diodos como si fueran independientes ya que solamente disponemos de pines que se corresponde con filas y columnas. Para mostrar un gr\u00e1fico o letra en la matriz lo que en realidad hay que hacer es componer ese gr\u00e1fico por columnas y hacer un recorrido de todos los necesarios como para que la percepci\u00f3n visual nos haga creer que estamos viendo ese gr\u00e1fico o texto. Utilizar la matriz de esta forma se antoja complejo y adem\u00e1s son necesarios muchas patillas de la placa de control, por no hablar de que adem\u00e1s se requiere de una resistencia en cada fila para limitar la corriente por los LEDs. Para evitar esta complejidad se utilizan circuitos integrados especializados en el control de LEDs como el HT16K33 o el MAX7219 de los que tenemos su hojas de datos en los enlaces anteriores. Matriz de 8x8 LEDs I2C \u00b6 Basada en el circuito HT16K33 que es un controlador de LED multifunci\u00f3n. El n\u00fameros de segmentos de visualizaci\u00f3n en el dispositivo es 128. El HT16K33 es compatible con la mayor\u00eda de los microcontroladores y se comunica a trav\u00e9s de un bus I2C bidireccional de dos l\u00edneas. El chip de control tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s el m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El aspecto del dispositivo visto por ambas caras es el de la figura siguiente: Aspecto de la matriz I2C de 8x8 Sus principales caracter\u00edsticas son: Matriz de LEDs de 8 filas y 8 columnas Direccionada por un chip HT16K33 Conexi\u00f3n tipo I2C Tensi\u00f3n de alimentaci\u00f3n: 5V Frecuencia de trabajo: 400KHz Potencia de entrada: 2.5W Corriente de entrada: 500mA Las comunicaciones I2C \u00b6 El bus conocido por las siglas I2C, IIC o I\u00b2C (del ingl\u00e9s Inter-Integrated Circuit = Circuito inter-integrado), es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la figura siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores (ejemplo de la matriz de 8x8), o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el marte prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la figura vemos un cronograma ejemplo del funcionamiento del sistema. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo. Escanear dispositivos I2C \u00b6 Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto, en esta ocasi\u00f3n, de tipo \"Arduino UNO\" para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la figura siguiente: Menu I2C Un sencillo programa como el de la figura siguiente nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. Programa Escaner-I2C El resultado de tener conectada una LCD I2C al puerto lo vemos en la figura siguiente: Consola para el programa Escaner-I2C Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C \u00b6 Esta tarea nos va a resultar especialmente \u00fatil si disponemos de dispositivos I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varios de ellos en nuestro proyecto. En el caso de las matrices de 8x8 LEDs tenemos los dos tipos que vemos en la figura siguiente: Pads y microinterruptores para configuraci\u00f3n direcci\u00f3n f\u00edsica I2C Si no fijamos en la parte posterior vemos los tres grupos de pads enmarcados en verde que se nombran A2, A1 y A0 de izquierda a derecha que nos permiten por soldadura cambiar la direcci\u00f3n f\u00edsica. A2 es el bit de mayor peso y A0 es el de menor peso, de forma que si los pads est\u00e1n unidos suman su peso y si no lo est\u00e1n no suman. La direcci\u00f3n final es 0x70 + A2 + A1 + A0 seg\u00fan la siguiente tabla: A2 (2\u00b2=4) A1 (2\u00b9=2) A0 (2\u2070=1) Direcci\u00f3n C\u00e1lculo 0 0 0 0x70 0x70 + 0 + 0 + 0 0 0 1 0x71 0x70 + 0 + 0 + 1 0 1 0 0x72 0x70 + 0 + 2 + 0 0 1 1 0x73 0x70 + 0 + 2 + 1 1 0 0 0x74 0x70 + 4 + 0 + 0 1 0 1 0x75 0x70 + 4 + 0 + 1 1 1 0 0x76 0x70 + 4 + 2 + 0 1 1 1 0x77 0x70 + 4 + 2 + 1 Como ayuda para conectar dispositivos I2C a nuestra placa de control expandiendo el conector I2C utilizamos la shield de conversi\u00f3n I2C que vemos en la figura siguiente. Hub I2C Programaci\u00f3n por bloques \u00b6 Esta matriz la vamos a programar con ArduinoBlocks, donde tenemos disponibles los bloques y el dise\u00f1ador de mapas de bits que podemos apreciar en la figura siguiente: Bloques en ArduinoBlocks para la matriz I2C de 8x8 y dise\u00f1ador Caritas Vamos a hacer un programa que muestre una carita sonriente dos segundos, despu\u00e9s una carita triste otros dos y finalmente que nos muestre un coraz\u00f3n latiendo. Comenzamos por dise\u00f1ar los corazones que van a quedar como vemos en la figura siguiente: Dise\u00f1o de corazones El programa caritas es el que vemos en la figura siguiente: Caritas Texto Vamos a crear un programa que nos muestre un texto desplaz\u00e1ndose, es decir, con una sola matriz vamos a mostrar el texto \"ArduinoBlocks\". El programa texto lo vemos en la figura siguiente: Texto que se desplaza Si observamos detenidamente el contador se decrementa y por lo tanto es necesario detenerlo en un valor que haga que el texto aparezca entero y que reinicie la variable del contador, y esta es la misi\u00f3n del condicional dentro del bucle. La idea de hacerlo de esta forma es que el texto de desplace hacia la izquierda. Dibujos El siguiente ejemplo es una sencilla muestra del resto de bloques disponibles. El programa dibujos est\u00e1 disponible en el enlace anterior. Dibujos Matriz de 8x8 LEDs con MAX7219 \u00b6 Los MAX7219/MAX7221 son controladores de c\u00e1todo com\u00fan para pantallas LED num\u00e9ricas de 7 segmentos de hasta 8 d\u00edgitos, gr\u00e1ficos de barras, paneles industriales y matriz de 64 LEDs. En el chip se incluyen un decodificador BCD, un circuito m\u00faltiplexador, controladores de segmentos y d\u00edgitos, y memoria RAM est\u00e1tica de 8x8 que almacena cada d\u00edgito. Sus principales caracter\u00edsticas son: Interfaz de control serie Conexi\u00f3n en cascada Modo de bajo consumo Solamente son necesarios tres pines de la placa para controlar la matriz o matrices, ya que se pueden conectar varios MAX7219 en cascada y con un consumo de solo 120 uA. seguimos por M\u00f3dulos de matriz LED con Arduino basados en MAX7219 ponemos los tipos incluida la de 4 de 8x8","title":"Matrices de 8x8 LEDs"},{"location":"temas/LED8x8/#matrices-de-8x8-leds","text":"Fundamentalmente, aunque su aspecto exterior es id\u00e9ntico, vamos a distinguir dos tipos: Matriz de 8x8 LEDs sin controlador Matrices I2C controladas por el chip HT16K33 como las que se contemplan en ArduinoBlocks. Matrices controladas por el chip MAX7219 o MAX7221 que se controlan con la librer\u00eda MD_MAX72xx","title":"Matrices de 8x8 LEDs"},{"location":"temas/LED8x8/#matriz-de-8x8-leds","text":"Se trata simplemente de diodos LED dispuestos en forma de matriz de 8x8 en los que se han unido por filas todos los c\u00e1todos o todos los \u00e1nodos de los diodos y se ha hecho lo propio con la otra patilla de cada columna. Esto da lugar a los dos tipos posibles de matrices, de \u00e1nodo com\u00fan o de c\u00e1todo com\u00fan. En la figura siguiente vemos el aspecto externo de estos elementos y los diagramas de conexi\u00f3n interna de cada tipo. Aspecto y diagramas de conexi\u00f3n interna La m\u00e1s com\u00fan dentro del mundo Arduino es la de c\u00e1todo com\u00fan para excitar los pines con niveles altos. En total una matriz de este tipo dispone de 16 patillas para controlar los 64 LEDs por lo que es evidente que no se pueden controlar los diodos como si fueran independientes ya que solamente disponemos de pines que se corresponde con filas y columnas. Para mostrar un gr\u00e1fico o letra en la matriz lo que en realidad hay que hacer es componer ese gr\u00e1fico por columnas y hacer un recorrido de todos los necesarios como para que la percepci\u00f3n visual nos haga creer que estamos viendo ese gr\u00e1fico o texto. Utilizar la matriz de esta forma se antoja complejo y adem\u00e1s son necesarios muchas patillas de la placa de control, por no hablar de que adem\u00e1s se requiere de una resistencia en cada fila para limitar la corriente por los LEDs. Para evitar esta complejidad se utilizan circuitos integrados especializados en el control de LEDs como el HT16K33 o el MAX7219 de los que tenemos su hojas de datos en los enlaces anteriores.","title":"Matriz de 8x8 LEDs"},{"location":"temas/LED8x8/#matriz-de-8x8-leds-i2c","text":"Basada en el circuito HT16K33 que es un controlador de LED multifunci\u00f3n. El n\u00fameros de segmentos de visualizaci\u00f3n en el dispositivo es 128. El HT16K33 es compatible con la mayor\u00eda de los microcontroladores y se comunica a trav\u00e9s de un bus I2C bidireccional de dos l\u00edneas. El chip de control tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s el m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El aspecto del dispositivo visto por ambas caras es el de la figura siguiente: Aspecto de la matriz I2C de 8x8 Sus principales caracter\u00edsticas son: Matriz de LEDs de 8 filas y 8 columnas Direccionada por un chip HT16K33 Conexi\u00f3n tipo I2C Tensi\u00f3n de alimentaci\u00f3n: 5V Frecuencia de trabajo: 400KHz Potencia de entrada: 2.5W Corriente de entrada: 500mA","title":"Matriz de 8x8 LEDs I2C"},{"location":"temas/LED8x8/#las-comunicaciones-i2c","text":"El bus conocido por las siglas I2C, IIC o I\u00b2C (del ingl\u00e9s Inter-Integrated Circuit = Circuito inter-integrado), es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la figura siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores (ejemplo de la matriz de 8x8), o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el marte prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la figura vemos un cronograma ejemplo del funcionamiento del sistema. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo.","title":"Las comunicaciones I2C"},{"location":"temas/LED8x8/#escanear-dispositivos-i2c","text":"Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto, en esta ocasi\u00f3n, de tipo \"Arduino UNO\" para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la figura siguiente: Menu I2C Un sencillo programa como el de la figura siguiente nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. Programa Escaner-I2C El resultado de tener conectada una LCD I2C al puerto lo vemos en la figura siguiente: Consola para el programa Escaner-I2C","title":"Escanear dispositivos I2C"},{"location":"temas/LED8x8/#cambiar-la-direccion-fisica-del-dispositivo-i2c","text":"Esta tarea nos va a resultar especialmente \u00fatil si disponemos de dispositivos I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varios de ellos en nuestro proyecto. En el caso de las matrices de 8x8 LEDs tenemos los dos tipos que vemos en la figura siguiente: Pads y microinterruptores para configuraci\u00f3n direcci\u00f3n f\u00edsica I2C Si no fijamos en la parte posterior vemos los tres grupos de pads enmarcados en verde que se nombran A2, A1 y A0 de izquierda a derecha que nos permiten por soldadura cambiar la direcci\u00f3n f\u00edsica. A2 es el bit de mayor peso y A0 es el de menor peso, de forma que si los pads est\u00e1n unidos suman su peso y si no lo est\u00e1n no suman. La direcci\u00f3n final es 0x70 + A2 + A1 + A0 seg\u00fan la siguiente tabla: A2 (2\u00b2=4) A1 (2\u00b9=2) A0 (2\u2070=1) Direcci\u00f3n C\u00e1lculo 0 0 0 0x70 0x70 + 0 + 0 + 0 0 0 1 0x71 0x70 + 0 + 0 + 1 0 1 0 0x72 0x70 + 0 + 2 + 0 0 1 1 0x73 0x70 + 0 + 2 + 1 1 0 0 0x74 0x70 + 4 + 0 + 0 1 0 1 0x75 0x70 + 4 + 0 + 1 1 1 0 0x76 0x70 + 4 + 2 + 0 1 1 1 0x77 0x70 + 4 + 2 + 1 Como ayuda para conectar dispositivos I2C a nuestra placa de control expandiendo el conector I2C utilizamos la shield de conversi\u00f3n I2C que vemos en la figura siguiente. Hub I2C","title":"Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C"},{"location":"temas/LED8x8/#programacion-por-bloques","text":"Esta matriz la vamos a programar con ArduinoBlocks, donde tenemos disponibles los bloques y el dise\u00f1ador de mapas de bits que podemos apreciar en la figura siguiente: Bloques en ArduinoBlocks para la matriz I2C de 8x8 y dise\u00f1ador Caritas Vamos a hacer un programa que muestre una carita sonriente dos segundos, despu\u00e9s una carita triste otros dos y finalmente que nos muestre un coraz\u00f3n latiendo. Comenzamos por dise\u00f1ar los corazones que van a quedar como vemos en la figura siguiente: Dise\u00f1o de corazones El programa caritas es el que vemos en la figura siguiente: Caritas Texto Vamos a crear un programa que nos muestre un texto desplaz\u00e1ndose, es decir, con una sola matriz vamos a mostrar el texto \"ArduinoBlocks\". El programa texto lo vemos en la figura siguiente: Texto que se desplaza Si observamos detenidamente el contador se decrementa y por lo tanto es necesario detenerlo en un valor que haga que el texto aparezca entero y que reinicie la variable del contador, y esta es la misi\u00f3n del condicional dentro del bucle. La idea de hacerlo de esta forma es que el texto de desplace hacia la izquierda. Dibujos El siguiente ejemplo es una sencilla muestra del resto de bloques disponibles. El programa dibujos est\u00e1 disponible en el enlace anterior. Dibujos","title":"Programaci\u00f3n por bloques"},{"location":"temas/LED8x8/#matriz-de-8x8-leds-con-max7219","text":"Los MAX7219/MAX7221 son controladores de c\u00e1todo com\u00fan para pantallas LED num\u00e9ricas de 7 segmentos de hasta 8 d\u00edgitos, gr\u00e1ficos de barras, paneles industriales y matriz de 64 LEDs. En el chip se incluyen un decodificador BCD, un circuito m\u00faltiplexador, controladores de segmentos y d\u00edgitos, y memoria RAM est\u00e1tica de 8x8 que almacena cada d\u00edgito. Sus principales caracter\u00edsticas son: Interfaz de control serie Conexi\u00f3n en cascada Modo de bajo consumo Solamente son necesarios tres pines de la placa para controlar la matriz o matrices, ya que se pueden conectar varios MAX7219 en cascada y con un consumo de solo 120 uA. seguimos por M\u00f3dulos de matriz LED con Arduino basados en MAX7219 ponemos los tipos incluida la de 4 de 8x8","title":"Matriz de 8x8 LEDs con MAX7219"},{"location":"temas/alimentar/","text":"Alimentaci\u00f3n de Neopixeles \u00b6 Vamos a comenzar por dar de forma destacada las tres recomendaciones que indican en la gu\u00eda de Adafruit, que son: Proyectos port\u00e1tiles \u00b6 Se configuran con relativamente pocos LEDs y por lo tanto no tienen un excesivo consumo por lo que podemos alimentarlos con pilas o bater\u00edas. Las bater\u00edas recargables de una celda (figura siguiente) de pol\u00edmero de litio entregan 3,7V que son perfectos para alimentar microcontroladores y unos pocos LEDs direccionables. Bater\u00edas Lipo 1S Pilas AA o AAA. Se pueden usar tres pilas alcalinas con su correspondiente portapilas. Esto proporciona 4.5V. El inconveniente respecto a las bater\u00edas lipo es que son mas grandes y pesadas y la ventaja es que son muy f\u00e1ciles de conseguir. Pilas recargables de hidruro met\u00e1lico de n\u00edquel. En este caso hay que utilizar cuatro unidades de 1.2V con su soporte de cuatro celdas. Esto nos va a proporcionar 4.8V. Tenemos que asegurarnos de usar solamente pilas NiMH porque si colocamos pilas normales de 1.5V estaremos creando una tensi\u00f3n total de 6V y esto es muy probable que rompa el microcontrolador o alg\u00fan LED. Otros medios pueden ser utilizar porwerbanks de la tensi\u00f3n adecuada o alguna de las anteriores de mayor tensi\u00f3n intercalando un convertidor reductor que se adapte a las condiciones de entrada de tensi\u00f3n de que disponemos y que su salida suministre los 5V requeridos. Hay que tener en cuenta el rango de tensi\u00f3n de entrada que requiere el convertidor espec\u00edfico y la corriente m\u00e1xima de salida.amperimetro Proyectos de escritorio \u00b6 Si estamos hablando de tiras de hasta un metro con una fuente de alimentaci\u00f3n conmutada de 5V/2A en CC t\u00edpica tendremos suficiente. Si se requiere mas corriente resulta tentador utilizar una fuente de laboratorio, pero hay que mucho cuidado porque pueden producir un gran pico de tensi\u00f3n cuando se encienden. Este pico es mas que suficiente para destruir instant\u00e1neamente los LEDs direccionables. Si se usa una fuente de laboratorio, NO conectamos la tira directamente. Primero encendemos la fuente de alimentaci\u00f3n, dejamos pasar unos segundo que el voltaje se estabilice, luego conectamos la tira, asegur\u00e1ndonos de conectar en primer lugar GND. Requisitos de energia \u00b6 Cada LED individual consume hasta 60 miliamperios con el m\u00e1ximo brillo blanco (rojo + verde + azul). Sin embargo, en el uso real, es raro que todos los p\u00edxeles se enciendan de esa manera. Al mezclar colores y mostrar animaciones, el consumo puntual ser\u00e1 mucho menor. Es imposible estimar un n\u00famero para todas las circunstancias, pero se ha experimentado que usando la tercera parte de los 60 mA (20 mA por p\u00edxel) como regla general funciona correctamente. Pero si sabemos con certeza que necesitamos cada p\u00edxel con el m\u00e1ximo brillo, tenemos que usar la cifra 60 mA. Para estimar las necesidades de suministro de energ\u00eda, basta multiplicar la cantidad de p\u00edxeles por 20, o por 60 mA y obtendremos el consumo total en miliamperios. Por ejemplo: 60 LEDs \u00d7 20 mA = 1200 mA = 1.2 A como m\u00ednimo 60 LEDs \u00d7 60 mA = 3600 mA = 3.6 A como m\u00ednimo 256 LEDs x 20 mA = 5120 mA = 5.12 A como m\u00ednimo 256 LEDs x 60 mA = 15360 mA = 15.36 A como m\u00ednimo La elecci\u00f3n de la fuente de alimentaci\u00f3n depende de nosotros pero es evidente que la m\u00e1xima seguridad y fiabilidad se consigue con una fuente de alimentaci\u00f3n de dimensiones m\u00e1s generosas, y esto es lo que recomendamos. La mayor\u00eda de las fuentes de alimentaci\u00f3n pueden entregar un poco de corriente adicional durante per\u00edodos breves de tiempo e incluso algunas contienen un fusible t\u00e9rmico y simplemente se apagar\u00e1n si se sobrecargan. Por lo tanto, aunque t\u00e9cnicamente pueden funcionar, digamos que no es recomendable abusar de ellas. Un factor a tener en cuenta es que si vamos a alimentar con bater\u00edas estas se vuelven progresivamente mas pesadas, costosas y peligrosas, as\u00ed que por razones de seguridad habr\u00eda que minimizar el tama\u00f1o de las bater\u00edas. Por otro lado tenemos que tener en cuenta la secci\u00f3n del conductor que ser\u00e1 m\u00e1s barato y menos pesado cuanto menor sea esta, es decir, cuanta menor corriente deba soportar y que cuanto menor sea la corriente menor ser\u00e1 el calor generado. En general podemos decir que: La regla general de los \"60 miliamperios\" es solo eso... una regla general, no ciencia pura. Al animar y mezclar colores, el consumo de corriente ser\u00e1 menor. A veces mucho menos. Incluso cuando se establece el color en 0 (LEDs apagados), la l\u00f3gica del controlador dentro de cada Pixel usa una peque\u00f1a cantidad de corriente por debajo de 1 miliamperio por p\u00edxel, pero con muchos p\u00edxeles esto deber\u00eda tambi\u00e9n sumarse. La biblioteca NeoMatrix utiliza la correcci\u00f3n gamma para seleccionar niveles de brillo que son visualmente (aunque no num\u00e9ricamente) equidistantes. Hay 32 niveles para rojo y azul, 64 niveles para verde. La funci\u00f3n Color() realiza la conversi\u00f3n necesaria; no necesitamos hacer ning\u00fan c\u00e1lculo. Acepta valores de rojo, verde y azul de 8 bits y devuelve un color de 16 bits con correcci\u00f3n gamma. La respuesta final a todo esto es que usualmente los LEDs no estar\u00edan encendidos todos juntos, por lo que elegir una fuente de alimentaci\u00f3n se vuelve una adivinanza. Podemos asumir para nuestros proyectos que el 75% de los pixels est\u00e1n encendidos en cualquier momento y que cada uno tiene solo un color, con lo que las corrientes anteriores quedan as\u00ed: 60 LEDs: 45\u00d720 mA = 0.9 A 256 LEDs: 192 x 20 mA = 3.84 A 512 LEDs: 384 x 20 mA = 7.68 A La \u00fanica forma 100% segura de saber con certeza el consumo es programar las luces y medir el consumo de corriente con un amper\u00edmetro.","title":"Alimentaci\u00f3n"},{"location":"temas/alimentar/#alimentacion-de-neopixeles","text":"Vamos a comenzar por dar de forma destacada las tres recomendaciones que indican en la gu\u00eda de Adafruit, que son:","title":"Alimentaci\u00f3n de Neopixeles"},{"location":"temas/alimentar/#proyectos-portatiles","text":"Se configuran con relativamente pocos LEDs y por lo tanto no tienen un excesivo consumo por lo que podemos alimentarlos con pilas o bater\u00edas. Las bater\u00edas recargables de una celda (figura siguiente) de pol\u00edmero de litio entregan 3,7V que son perfectos para alimentar microcontroladores y unos pocos LEDs direccionables. Bater\u00edas Lipo 1S Pilas AA o AAA. Se pueden usar tres pilas alcalinas con su correspondiente portapilas. Esto proporciona 4.5V. El inconveniente respecto a las bater\u00edas lipo es que son mas grandes y pesadas y la ventaja es que son muy f\u00e1ciles de conseguir. Pilas recargables de hidruro met\u00e1lico de n\u00edquel. En este caso hay que utilizar cuatro unidades de 1.2V con su soporte de cuatro celdas. Esto nos va a proporcionar 4.8V. Tenemos que asegurarnos de usar solamente pilas NiMH porque si colocamos pilas normales de 1.5V estaremos creando una tensi\u00f3n total de 6V y esto es muy probable que rompa el microcontrolador o alg\u00fan LED. Otros medios pueden ser utilizar porwerbanks de la tensi\u00f3n adecuada o alguna de las anteriores de mayor tensi\u00f3n intercalando un convertidor reductor que se adapte a las condiciones de entrada de tensi\u00f3n de que disponemos y que su salida suministre los 5V requeridos. Hay que tener en cuenta el rango de tensi\u00f3n de entrada que requiere el convertidor espec\u00edfico y la corriente m\u00e1xima de salida.amperimetro","title":"Proyectos port\u00e1tiles"},{"location":"temas/alimentar/#proyectos-de-escritorio","text":"Si estamos hablando de tiras de hasta un metro con una fuente de alimentaci\u00f3n conmutada de 5V/2A en CC t\u00edpica tendremos suficiente. Si se requiere mas corriente resulta tentador utilizar una fuente de laboratorio, pero hay que mucho cuidado porque pueden producir un gran pico de tensi\u00f3n cuando se encienden. Este pico es mas que suficiente para destruir instant\u00e1neamente los LEDs direccionables. Si se usa una fuente de laboratorio, NO conectamos la tira directamente. Primero encendemos la fuente de alimentaci\u00f3n, dejamos pasar unos segundo que el voltaje se estabilice, luego conectamos la tira, asegur\u00e1ndonos de conectar en primer lugar GND.","title":"Proyectos de escritorio"},{"location":"temas/alimentar/#requisitos-de-energia","text":"Cada LED individual consume hasta 60 miliamperios con el m\u00e1ximo brillo blanco (rojo + verde + azul). Sin embargo, en el uso real, es raro que todos los p\u00edxeles se enciendan de esa manera. Al mezclar colores y mostrar animaciones, el consumo puntual ser\u00e1 mucho menor. Es imposible estimar un n\u00famero para todas las circunstancias, pero se ha experimentado que usando la tercera parte de los 60 mA (20 mA por p\u00edxel) como regla general funciona correctamente. Pero si sabemos con certeza que necesitamos cada p\u00edxel con el m\u00e1ximo brillo, tenemos que usar la cifra 60 mA. Para estimar las necesidades de suministro de energ\u00eda, basta multiplicar la cantidad de p\u00edxeles por 20, o por 60 mA y obtendremos el consumo total en miliamperios. Por ejemplo: 60 LEDs \u00d7 20 mA = 1200 mA = 1.2 A como m\u00ednimo 60 LEDs \u00d7 60 mA = 3600 mA = 3.6 A como m\u00ednimo 256 LEDs x 20 mA = 5120 mA = 5.12 A como m\u00ednimo 256 LEDs x 60 mA = 15360 mA = 15.36 A como m\u00ednimo La elecci\u00f3n de la fuente de alimentaci\u00f3n depende de nosotros pero es evidente que la m\u00e1xima seguridad y fiabilidad se consigue con una fuente de alimentaci\u00f3n de dimensiones m\u00e1s generosas, y esto es lo que recomendamos. La mayor\u00eda de las fuentes de alimentaci\u00f3n pueden entregar un poco de corriente adicional durante per\u00edodos breves de tiempo e incluso algunas contienen un fusible t\u00e9rmico y simplemente se apagar\u00e1n si se sobrecargan. Por lo tanto, aunque t\u00e9cnicamente pueden funcionar, digamos que no es recomendable abusar de ellas. Un factor a tener en cuenta es que si vamos a alimentar con bater\u00edas estas se vuelven progresivamente mas pesadas, costosas y peligrosas, as\u00ed que por razones de seguridad habr\u00eda que minimizar el tama\u00f1o de las bater\u00edas. Por otro lado tenemos que tener en cuenta la secci\u00f3n del conductor que ser\u00e1 m\u00e1s barato y menos pesado cuanto menor sea esta, es decir, cuanta menor corriente deba soportar y que cuanto menor sea la corriente menor ser\u00e1 el calor generado. En general podemos decir que: La regla general de los \"60 miliamperios\" es solo eso... una regla general, no ciencia pura. Al animar y mezclar colores, el consumo de corriente ser\u00e1 menor. A veces mucho menos. Incluso cuando se establece el color en 0 (LEDs apagados), la l\u00f3gica del controlador dentro de cada Pixel usa una peque\u00f1a cantidad de corriente por debajo de 1 miliamperio por p\u00edxel, pero con muchos p\u00edxeles esto deber\u00eda tambi\u00e9n sumarse. La biblioteca NeoMatrix utiliza la correcci\u00f3n gamma para seleccionar niveles de brillo que son visualmente (aunque no num\u00e9ricamente) equidistantes. Hay 32 niveles para rojo y azul, 64 niveles para verde. La funci\u00f3n Color() realiza la conversi\u00f3n necesaria; no necesitamos hacer ning\u00fan c\u00e1lculo. Acepta valores de rojo, verde y azul de 8 bits y devuelve un color de 16 bits con correcci\u00f3n gamma. La respuesta final a todo esto es que usualmente los LEDs no estar\u00edan encendidos todos juntos, por lo que elegir una fuente de alimentaci\u00f3n se vuelve una adivinanza. Podemos asumir para nuestros proyectos que el 75% de los pixels est\u00e1n encendidos en cualquier momento y que cada uno tiene solo un color, con lo que las corrientes anteriores quedan as\u00ed: 60 LEDs: 45\u00d720 mA = 0.9 A 256 LEDs: 192 x 20 mA = 3.84 A 512 LEDs: 384 x 20 mA = 7.68 A La \u00fanica forma 100% segura de saber con certeza el consumo es programar las luces y medir el consumo de corriente con un amper\u00edmetro.","title":"Requisitos de energia"},{"location":"temas/matriz16x16/","text":"Matriz o panel de 16x16 \u00b6 Descripci\u00f3n \u00b6 En realidad se trata de tiras de 256 LEDs dispuestos en forma de panel o matriz que tienen el aspecto de la figura siguiente: Aspecto de una matriz de 16x16 Podemos decir que todo lo dicho para la matriz de 8x32 es v\u00e1lido para esta salvo la disposici\u00f3n que en lugar de ser rectangular es cuadrada. Con las adaptaciones adecuadas incluso los ejemplos siguen la misma filosof\u00eda si utilizamos las librer\u00edas citadas en la secci\u00f3n Matrices de 8x32 . Librer\u00eda FastLED \u00b6 Es una alternativa a la librer\u00eda Adafruit_NeoPixel , que proporciona caracter\u00edsticas m\u00e1s avanzadas y funciona con otros tipos de LEDs como DotStars, que resultan tan interesantes que merecen ser tratados de forma separada. FastLED funciona de manera completamente diferente; no es un reemplazo directo para Adafruit_NeoPixel, y los programas que tengamos requerir\u00e1n ser reescritos. La librer\u00eda es compatible con este listado de chip y se ejecuta en una amplia gama de plataformas de Arduino y compatibles, incluidos los basados en AVR y ARM. La librer\u00eda presenta las siguientes caracter\u00edsticas: Soporte para modelo de color HSV asi como el cl\u00e1sico RGB. En Setting HSV Colors tenemos detalles del tema en ingl\u00e9s. La configuraci\u00f3n del brillo permite controlar, ademas del brillo, el uso de energia y por lo tanto la duraci\u00f3n de una posible bater\u00eda, si se utiliza. Funciones matem\u00e1ticas y de acceso a memoria hasta 10 veces mas r\u00e1pidas que las cl\u00e1sicas de Arduino. Para comenzar basta con descargar la librer\u00eda y comenzar a probar c\u00f3digo b\u00e1sico. Lo que vamos a ver a continuaci\u00f3n es la informaci\u00f3n b\u00e1sica sobre el uso de la librer\u00eda. Configuraci\u00f3n de los LEDs \u00b6 Cuando vamos a escribir c\u00f3digo necesitamos saber que LEDs estamos utilizando, cuantos hay y a que pin de salida de datos los vamos a conectar. Para los siguientes ejemplos trabajamos con una tira de 256 LEDs dispuestos en forma de matriz de 16x16 y los conectaremos al pin digital 3. Entra dentro de las buenas pr\u00e1cticas en programaci\u00f3n hacer el c\u00f3digo lo mas f\u00e1cil de leer que sea posible y que cuando necesitemos realizar cambios en las condiciones lo tengamos que hacer solamente en un lugar. Como ejemplo a continuaci\u00f3n vemos dos formas de escribir una l\u00ednea de c\u00f3digo FastLED.addLeds<4, 3>(leds, 256); // Forma 1 FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); // Forma 2 La Forma 1 utiliza n\u00fameros simples para definir las cosas mientras que la Forma 2 utiliza nombres, lo que hace al c\u00f3digo mas legible y si, por ejemplo queremos cambiar el n\u00famero de LEDs basta con hacerlo en la definici\u00f3n de NUM_LEDS. Dicho esto nuestras primeras l\u00edneas de c\u00f3digo van a ser: #include <FastLED.h> // Incluimos la librer\u00eda #define NUM_LEDS 256 // Definimos el n\u00famero de LEDs #define DATA_PIN 3 // Definimos el pin de datos CRGB leds[NUM_LEDS]; // Configura el bloque de memoria (matriz) para almacenar y manipular datos del LED El siguiente paso es configurar nuestros LEDs en el bucle inicializar o setup. Esto se hace como vemos a continuaci\u00f3n: void setup() { FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); } La l\u00ednea de configuraci\u00f3n indica que hay una tira de NEOPIXEL conectada al pin 3, que esos LEDs utilizaran la matriz leds y en el n\u00famero definido de 256. Si estamos utilizando chips de cuatro cables debemos cambiar esta l\u00ednea de configuraci\u00f3n para lo que consultaremos la documentaci\u00f3n original indicada en los enlaces. Encender y apagar un LED \u00b6 El proceso de establecer un color para los LEDs se realiza estableciendo los valores de la matriz leds y posteriormente indicando a la biblioteca que muestre los datos. Por ejemplo, el siguiente c\u00f3digo enciende en verde el primer LED. void loop() { // Enciende el primer LED en verde leds[0] = CRGB::Green; FastLED.show(); delay(30); } El color es un tipo de dato enumerado (una lista de valores) que podemos consultar aqu\u00ed y que, como vemos en la animaci\u00f3n de la figura siguiente, se mostrar\u00e1n como opciones disponibles cuando tecleamos el color en la l\u00ednea de c\u00f3digo. Opciones de colores cuando tecleamos Apagar el LED consiste en ponerlo en color negro de forma similar a la vista anteriormente. El c\u00f3digo del programa completo Blynk es el siguiente: #include <FastLED.h> #define NUM_LEDS 256 #define DATA_PIN 3#include \"FastLED.h\" CRGB leds[60]; void setup() { FastLED.addLeds<NEOPIXEL, 6>(leds, 60); } void loop() { static uint8_t hue = 0; FastLED.showColor(CHSV(hue++, 255, 255)); delay(10); } CRGB leds[NUM_LEDS]; void setup() { FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); } void loop() { // Encender el primer LED en verde leds[0] = CRGB::Green; FastLED.show(); delay(1000); // Apagar el primer LED leds[0] = CRGB::Black; FastLED.show(); delay(1000); } Ejemplos \u00b6 A continuaci\u00f3n vamos a ver diferentes ejemplos comentando en cada uno el concepto relativo a la librer\u00eda que se introduce y, como no, que hace el programa. Encender y apagar todos los pixeles \u00b6 Simplemente hacemos un bucle para recorrer la tira completa y ver como est\u00e1n conectados los LEDs. El programa ON_OFF_todos tiene el siguiente c\u00f3digo: #include <FastLED.h> #define NUM_LEDS 256 #define DATA_PIN 3 CRGB leds[NUM_LEDS]; void setup() { FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); } void loop() { for(int pixel=0; pixel<NUM_LEDS; pixel++){ leds[pixel] = CRGB::Blue; FastLED.show(); // Apagar el LED encendido para ver la siguiente iteracion del bucle leds[pixel] = CRGB::Black; delay(50); } } Libreria HSV \u00b6 La librer\u00eda proporciona una conversi\u00f3n r\u00e1pida de HSV a RGB ajustada a la percepci\u00f3n humana del color. Al definir colores con RGB, estamos mezclando los valores de color rojo, verde y azul. Cuando usamos HSV estamos definiendo el tono del color (es decir, d\u00f3nde est\u00e1 en la rueda de colores), qu\u00e9 tan saturado est\u00e1 y qu\u00e9 tan brillante es. Por ejemplo, el programa HSV_color recorrer\u00e1 los colores del arco\u00edris. #include <FastLED.h> #define NUM_LEDS 256 #define DATA_PIN 3 #define BRILLO 15 CRGB leds[NUM_LEDS]; void setup() { FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); FastLED.setBrightness(BRILLO); } void loop() { static uint8_t matiz = 0; FastLED.showColor(CHSV(matiz++, 255, 255)); delay(10); } Ejemplos con ESP32 STEAMakers + TdR STEAM \u00b6 En este apartado vamos a crear alg\u00fan ejemplo utilizando este conjunto de placas de las que podemos encontrar informaci\u00f3n en Notas sobre ESP32 STEAMakers . Tambi\u00e9n vamos a ver los ejemplos disponibles en la p\u00e1gina 16x16 RGB LED Panel Arduino Projects by coberfranc en Autodesk Instructables. Para instalar las placas ESP32, nos dirigimos a 'URLs adicionales de gestor de placas' disponible en 'Preferencias' y pegaremos la URL . Esto har\u00e1 que tengamos estas placas disponibles en el gestor de placas desde podemos instalarlas. Siempre vamos a partir de la base de que en el gestor de placas ya hemos instalado el Arduino Core for ESP32 de Espressif Systems tal y como vemos en la figura siguiente: esp32 instalado En la figura podemos tambi\u00e9n ver la selecci\u00f3n de placa y de puerto realizada. Blink con LED rojo \u00b6 Vamos a comenzar por este sencillo ejemplo que nos servir\u00e1 para describir el entorno en el que vamos a programar. Analizando la documentaci\u00f3n vemos que el LED rojo est\u00e1 conectado al pin D12 que se corresponde con el pin IO19 o pin 19 de prop\u00f3sito general de entrada salida en la ESP32. El c\u00f3digo del programa lo tenemos a continuaci\u00f3n: void setup() { pinMode(19, OUTPUT); } void loop() { digitalWrite(19,HIGH); delay(1000); digitalWrite(19, LOW); delay(1000); } Encender pixeles con potenci\u00f3metro \u00b6 Vamos a tener el potenci\u00f3metro conectado al pin A0 de la TdR STEAM, que en la ESP32 es el pin IO02, y nos entregar\u00e1 un valor de 0 a 4095 (DAC de 12 bits). Utilizando la funci\u00f3n de mapeo convertimos ese rango de valores en un nuevo rango que ser\u00e1 el n\u00famero de LEDs. El pin que vamos a utilizar como salida de datos es el asociado al conector D3, que en la ESP32 es el pin IO25. El programa NLEDs_pot tiene el c\u00f3digo siguiente: #include <FastLED.h> #define NUM_LEDS_M 256 #define DATA_PIN 25 #define BRILLO 15 CRGB leds[NUM_LEDS_M]; void setup() { pinMode(DATA_PIN, OUTPUT); FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS_M); FastLED.setBrightness(BRILLO); } void loop() { int num = analogRead(2); int pixelesON = map(num, 0, 4095, 0, NUM_LEDS_M); FastLED.clear(); // Limpiamos la matriz for(int led = 0; led < pixelesON; led++) { leds[led] = CRGB::Purple; } FastLED.show(); } En el siguiente video vemos el funcionamiento del ejemplo: Colores aleatorios en el panel \u00b6 Se trata del ejemplo 16random.ino en el que se van encendiendo de forma y en color aleatorio diferentes pixeles. Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: #include \"FastLED.h\" #define NUM_LEDS 256 #define DATA_PIN 25 CRGB leds[NUM_LEDS]; void setup() { delay(2000); FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS); FastLED.setBrightness(10); //Numero de 0 a 255 FastLED.clear(); } int random_integer; int random_integer2; void loop() { for(int i = 0; i <center 5; i++){ for(int j = 0; j <center 256; j++){ random_integer = (rand()%256)+1; random_integer2 = (rand()%256)+1; leds[random_integer].setHue(random_integer2); FastLED.show(); delay(100); } for(int k = 256; k > 0; k--){ leds[k] = CRGB::Black; } } } El video siguiente nos muestra el funcionamiento del ejemplo: Paleta de Colores en el panel \u00b6 Se trata del ejemplo 16counter.ino en el que en un primer bucle que iteraciona tres veces se encienden todos los LEDs de uno en uno cambiando de color hasta que est\u00e1n todos encendidos que es cuando comienzan a apagarse de forma inversa. En otro bucle similar se encienden todos los LEDs pero de uno en uno tambi\u00e9n cambiando de color y comenzando las tres veces desde el principio. Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: #include \"FastLED.h\" #define NUM_LEDS 256 #define DATA_PIN 25 CRGB leds[NUM_LEDS]; void setup() { delay(2000); FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS); FastLED.setBrightness(10); //Number 0-255 FastLED.clear(); } int colorcalc; void loop() { colorcalc = 0; for(int i = 0; i < 3; i++){ for(int j = 0; j < 256; j++){ colorcalc = colorcalc + 1; leds[j].setHue(colorcalc);luces FastLED.show(); delay(20); } for(int j = 256; j > 0; j--){ leds[j] = CRGB::Black; FastLED.show(); delay(20);luces } } for(int i = 0; i < 3; i++){ for(int j = 0; j < 256; j++){ colorcalc = colorcalc + 1; leds[j].setHue(colorcalc); FastLED.show(); delay(20); leds[j] = CRGB::Black; FastLED.show(); } }luces } El video siguiente nos muestra el funcionamiento del ejemplo: Pacman \u00b6 Se trata del ejemplo 16pacman.ino en el que se ver\u00e1 el cl\u00e1sico Pacman amarillo animado. El dise\u00f1o se ayuda de una tabla que act\u00faa a modo de plantilla. En la tabla se hace coincidir cada n\u00famero de celda con su n\u00famero de pixel correspondiente seg\u00fan la relaci\u00f3n de la figura siguiente: Plantilla 16x16 para dise\u00f1o luces El color negro de fondo representa el apagado de los LEDs. En la figura siguiente vemos el dise\u00f1o del cuerpo del Pacman Cuerpo del Pacman En la figura siguiente vemos el dise\u00f1o de la boca medio abierta. Boca medio abierta En la figura siguiente vemos el dise\u00f1o de la boca abierta. Boca abierta Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: #include \"FastLED.h\" #define NUM_LEDS 256luces #define DATA_PIN 25 CRGB leds[NUM_LEDS]; void setup() { delay(2000); FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS); FastLED.setBrightness(10); FastLED.clear(); } int eyes_seconds = 2;luces int reg_ghost_seconds = 10; int feet_delay = 220; int eye_loop = (eyes_seconds*1000)/feet_delay; int reg_ghost_loop = reg_ghost_seconds/eyes_seconds; int sad_ghost_loop = 50; int sad_ghost_blink_loop = 10; int body[] = { 5,6,7,8,9,10,19,20,21,22, 23,24,25,26,27,28,34,35,36,37, 38,39,40,41,42,43,44,45,49,50, 51,52,53,54,55,56,57,58,59,60, 61,62,65,66,67,68,69,70,71,72, 73,74,75,76,77,78,80,81,82,83, 84,85,86,87,88,89,90,91,92,93, 94,95,96,97,98,99,100,101,102,103, 104,105,106,107,108,109,110,111,112,113, 114,115,116,117,118,119,120,121,122,123, 124,125,126,127,128,129,130,131,132,133, 134,135,136,137,138,139,140,141,142,143, 144,145,146,147,148,149,150,151,152,153, 154,155,156,157,158,159,160,161,162,163, 164,165,166,167,168,169,170,171,172,173, 174,175,177,178,179,180,181,182,183,184, 185,186,187,188,189,190,193,194,195,196, 197,198,199,200,201,202,203,204,205,206, 210,211,212,213,214,215,216,217,218,219, 220,221,227,228,229,230,231,232,233,234, 235,236,245,246,247,248,249,250 }; int mouth_half_open[] = { 5,6,7,8,9,10,19,20,21,22, 23,24,25,26,27,28,35,36,37,38, 39,40,41,42,43,44,52,53,54,55, 56,57,58,59,68,69,70,71,72,73, 74,75,85,86,87,88,89,90,101,102, 103,104,105,106,118,119,120,121,134,135, 136,137,151,152 }; int mouth_open[] = {luces 5,6,7,8,9,10,19,20,21,22, 23,24,25,26,27,28,34,35,36,37, 38,39,40,41,42,43,44,45,49,50, 51,52,53,54,55,56,57,58,59,60, 61,62,65,66,67,68,69,70,71,72, 73,74,75,76,77,78,82,83,84,85, 86,87,88,89,90,91,92,93,99,100, 101,102,103,104,105,106,107,108,116,117, 118,119,120,121,122,123,133,134,135,136, 137,138,150,151,152,153luces }; int filler[] = { 138,116,117,107,108,84,83,82,78,77, 76,49,50,51,45,153,133,122,123,100, 99,91,92,93,67,66,65,60,61,62, 34 }; void loop() { for(int i = 0; i < reg_ghost_loop; i++){ for(int i = 0; i < eye_loop; i++){ //CUERPO for (int i = 0; i < 208; i++){ leds[body[i]] = CRGB::Yellow; } FastLED.show(); delay(200); //BOCA MEDIO ABIERTA for (int i = 0; i < 64; i++){ leds[mouth_half_open[i]] = CRGB::Black; } FastLED.show(); delay(200); //BOCA ABIERTA for (int i = 0; i < 96; i++){ leds[mouth_open[i]] = CRGB::Black; } FastLED.show(); delay(200); //CUERPO for (int i = 0; i < 31; i++){ leds[filler[i]] = CRGB::Yellow; } FastLED.show(); delay(200); } } } El video siguiente nos muestra el funcionamiento del ejemplo: Remolino de colores \u00b6 Se trata del ejemplo 16colormatrix.ino en el que se aplican funciones auxiliares para una matriz XY bidimensional. La funci\u00f3n XY(x,y) toma las coordenadas 'x e y' y devuelve el n\u00famero de \u00edndice LED, para usarla debemos invocarla as\u00ed: leds[ XY(x,y) ] == CRGB::Red; Esta funci\u00f3n no realiza ninguna comprobaci\u00f3n de errores. La funci\u00f3n XYsafe(x,y) toma las coordenadas 'x e y' y devuelve el n\u00famero de \u00edndice LED, para usarla debemos invocarla as\u00ed: leds[ XYsafe(x,y) ] == CRGB::Red; La verificaci\u00f3n de errores se realiza en los rangos de x e y, y se devuelve un \u00edndice de \"-1\". Tambi\u00e9n se define un par\u00e1metro para diferenciar la forma en que est\u00e1n conectados los LEDs que en los comentarios del ejemplo original indican lo siguiente: \" Vocabulario adicional: cualquier cosa que vaya en una direcci\u00f3n en una fila, y luego hacia atr\u00e1s en la fila siguiente, y as\u00ed sucesivamente, se llama \" Bustrofedon \", que significa \"como ara el buey\". \" Esta funci\u00f3n devolver\u00e1 el 'n\u00famero de \u00edndice de led' para un conjunto dado de coordenadas X e Y en la matriz si lo indicamos de manera correcta, es decir, la funci\u00f3n no controla LOS L\u00cdMITES DE COORDENADAS, as\u00ed que no debemos pasarle valores falsos. Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: #include <FastLED.h> #define LED_PIN 25 #define COLOR_ORDER GRB #define CHIPSET WS2812B #define BRIGHTNESS 10 // Parametros de anchura y altura const uint8_t kMatrixWidth = 16; const uint8_t kMatrixHeight = 16; // Parametro para diferenciar la forma de conexionado de los LEDs: // La ponemos a false si los pixeles est\u00e1n dispuestos como una tira // la ponemos a true si est\u00e1n dispuestos en zig-zag const bool kMatrixSerpentineLayout = true; uint16_t XY( uint8_t x, uint8_t y) { uint16_t i; if( kMatrixSerpentineLayout == false) { i = (y * kMatrixWidth) + x; } if( kMatrixSerpentineLayout == true) { if( y & 0x01) { // Odd rows run backwards uint8_t reverseX = (kMatrixWidth - 1) - x; i = (y * kMatrixWidth) + reverseX; } else { // Even rows run forwards i = (y * kMatrixWidth) + x; } } return i; } #define NUM_LEDS (kMatrixWidth * kMatrixHeight) CRGB leds_plus_safety_pixel[ NUM_LEDS + 1]; CRGB* const leds( leds_plus_safety_pixel + 1); void setup() { FastLED.addLeds<CHIPSET, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection(TypicalSMD5050); FastLED.setBrightness( BRIGHTNESS ); } uint16_t XYsafe( uint8_t x, uint8_t y) { if( x >= kMatrixWidth) return -1; if( y >= kMatrixHeight) return -1; return XY(x,y); } void loop() { uint32_t ms = millis(); int32_t yHueDelta32 = ((int32_t)cos16( ms * (27/1) ) * (350 / kMatrixWidth)); int32_t xHueDelta32 = ((int32_t)cos16( ms * (39/1) ) * (310 / kMatrixHeight)); DrawOneFrame( ms / 65536, yHueDelta32 / 32768, xHueDelta32 / 32768); if( ms < 5000 ) { FastLED.setBrightness( scale8( BRIGHTNESS, (ms * 256) / 5000)); } else { FastLED.setBrightness(BRIGHTNESS); } FastLED.show(); } void DrawOneFrame( byte startHue8, int8_t yHueDelta8, int8_t xHueDelta8) { byte lineStartHue = startHue8; for( byte y = 0; y < kMatrixHeight; y++) { lineStartHue += yHueDelta8; byte pixelHue = lineStartHue; for( byte x = 0; x < kMatrixWidth; x++) { pixelHue += xHueDelta8; leds[ XY(x, y)] = CHSV( pixelHue, 255, 255); } } } En el siguiente video vemos el funcionamiento del ejemplo: Fantasma PACMAN en rojo \u00b6 Se trata del ejemplo 16red.ino en el que se dibuja un fantasma de color rojo del juego PACMAN y se hace que mueva los ojos a izquierda y derecha y tambi\u00e9n que mueva los pies. El dise\u00f1o se ayuda de una tabla que act\u00faa a modo de plantilla. En la tabla se hace coincidir cada n\u00famero de celda con su n\u00famero de pixel correspondiente seg\u00fan la relaci\u00f3n de la figura siguiente: Plantilla 16x16 para dise\u00f1o El color negro de fondo representa el apagado de los LEDs. En la figura siguiente vemos el dise\u00f1o del fantasma mirando a su izquierda. Fantasma mirando a su izquierda En la figura siguiente vemos el dise\u00f1o del fantasma mirando a su derecha. Fantasma mirando a su derecha Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: //FANTASMA PACMAN ANIMADO #include \"FastLED.h\" #define NUM_LEDS 256 #define DATA_PIN 25 CRGB leds[NUM_LEDS]; void setup() { delay(2000); FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS); FastLED.setBrightness(10); //Numero entero entre 0 y 255 FastLED.clear(); } int body[] = { 0,1,2,3,4,5,6,7,21,22, 23,24,25,26,27,28,29,30,31,32, 33,34,35,36,37,38,39,40,41,42, 43,51,52,53,54,55,56,57,58,59, 60,61,62,63,64,65,66,67,68,69, 70,71,72,73,74,75,76,77,81,82, 83,84,85,86,87,88,89,90,91,92, 93,94,95,96,97,98,99,100,101,102, 103,104,105,106,107,108,109,110,113,114, 115,116,117,118,119,120,121,122,123,124, 125,126,127,128,129,130,131,132,133,134, 135,136,137,138,139,140,141,142,145,146, 147,148,149,150,151,152,153,154,155,156, 157,158,159,160,161,162,163,164,165,166, 167,168,169,170,171,172,173,174,178,179, 180,181,182,183,184,185,186,187,188,189, 190,191,192,193,194,195,196,197,198,199, 200,201,202,203,204,212,213,214,215,216, 217,218,219,220,221,222,223,224,225,226, 227,228,229,230,231,232,233,234,248,249, 250,251,252,253,254,255 }; int eyes_left[] = { 54,55,56, 70,71,72,73,74, 85,86,87,88,89, 103,104,105, 150,151,152, 166,167,168,169,170, 181,182,183,184,185, 199,200,201}; int eyes_right[] = { 71,72,73, 85,86,87,88,89, 102,103,104,105,106, 118,119,120, 169,168,167, 181,182,183,184,185, 202,201,200,199,198, 214,215,216}; int eyes_fill_body[] = { 149,150,151,152,153,53,54,55,56,57}; //eliminar pixeles alrededor de los pies int void_pixels_1[] = {8, 29, 30, 31, 83, 84, 85, 86, 138, 139, 140, 161}; int void_pixels_2[] = {7, 31, 55, 56, 57, 112, 113, 114, 138, 162}; int feet_fill_body[] = { 224,222,129,128,63,33}; int sad_ghost[] = {11, 26, 35, 48, 49, 53, 60, 64, 65, 80, 89, 104, 105, 109, 116, 120, 121, 134, 143, 158}; int eyes_seconds = 2; int reg_ghost_seconds = 10; int feet_delay = 220; int eye_loop = (eyes_seconds*1000)/feet_delay; // cuanto tiempo mira a izquierda y derecha int reg_ghost_loop = reg_ghost_seconds/eyes_seconds; int sad_ghost_loop = 50; int sad_ghost_blink_loop = 10; int pupil_right[] = { 151,152, 168,167, 72,71, 55,56}; int pupil_left[] = { 215,216, 200,199, 119,120, 104,103}; int feet_left[] = { 222,224,223,192, 129,126,128,127, 33,63,32,31}; int feet_right[] = { 255, 190,191,192,160, 65,64,63,95, 0}; int feet_fill[] = { 31,32,33, 224,223,222, 129,128,126,127}; int feet_fill2[] = { 31,32,33, 224,223,222, 129,128,126,127}; int feet_clear[] = { 254,225,222,193,190,161,158,129,126,97,94,65,62,33,30,1, 255,224,223,192,191,160,159,128,127,96,95,64,63,32,31,0 }; void loop() { for(int i = 0; i < reg_ghost_loop; i++){ for(int i = 0; i < eye_loop; i++){ //Cuerpo for (int i = 0; i < 206; i++){ leds[body[i]] = CRGB::Green; } //Ojos for (int i = 0; i < 32; i++){ leds[eyes_left[i]] = CRGB::White; } //Pupilas for (int i = 0; i < 8; i++){ leds[pupil_right[i]] = CRGB::DarkBlue; } FastLED.show(); //Pies for(int i = 0; i < 2; i++){ //configura pie for (int i = 0; i < 12; i++){ leds[feet_left[i]] = CRGB::Black; } FastLED.show(); delay(feet_delay); //configura pie for (int i = 0; i < 12; i++){ leds[feet_right[i]] = CRGB::Black; } for (int i = 0; i < 10; i++){ leds[feet_fill[i]] = CRGB::Green; } FastLED.show(); delay(feet_delay); for (int i = 0; i < 32; i++){ leds[feet_clear[i]] = CRGB::Green; } } //fin bucle pies //Cambio ojos //Cuerpo for (int i = 0; i < 206; i++){ leds[body[i]] = CRGB::Green; } //Ojos for (int i = 0; i < 32; i++){ leds[eyes_right[i]] = CRGB::White; } //Pupilas for (int i = 0; i < 8; i++){ leds[pupil_left[i]] = CRGB::DarkBlue; } FastLED.show(); //Pie for(int i = 0; i < 2; i++){ //configura pie for (int i = 0; i < 12; i++){ leds[feet_left[i]] = CRGB::Black; } FastLED.show(); delay(feet_delay); //configura pie for (int i = 0; i < 12; i++){ leds[feet_right[i]] = CRGB::Black; } for (int i = 0; i < 10; i++){ leds[feet_fill[i]] = CRGB::Green; } FastLED.show(); delay(feet_delay); for (int i = 0; i < 32; i++){ leds[feet_clear[i]] = CRGB::Green; } } //fin bucle pies } //fin bucle ojos } //fin bucle fantasma } En el siguiente video vemos el funcionamiento del ejemplo:","title":"Matriz WS2812 16x16"},{"location":"temas/matriz16x16/#matriz-o-panel-de-16x16","text":"","title":"Matriz o panel de 16x16"},{"location":"temas/matriz16x16/#descripcion","text":"En realidad se trata de tiras de 256 LEDs dispuestos en forma de panel o matriz que tienen el aspecto de la figura siguiente: Aspecto de una matriz de 16x16 Podemos decir que todo lo dicho para la matriz de 8x32 es v\u00e1lido para esta salvo la disposici\u00f3n que en lugar de ser rectangular es cuadrada. Con las adaptaciones adecuadas incluso los ejemplos siguen la misma filosof\u00eda si utilizamos las librer\u00edas citadas en la secci\u00f3n Matrices de 8x32 .","title":"Descripci\u00f3n"},{"location":"temas/matriz16x16/#libreria-fastled","text":"Es una alternativa a la librer\u00eda Adafruit_NeoPixel , que proporciona caracter\u00edsticas m\u00e1s avanzadas y funciona con otros tipos de LEDs como DotStars, que resultan tan interesantes que merecen ser tratados de forma separada. FastLED funciona de manera completamente diferente; no es un reemplazo directo para Adafruit_NeoPixel, y los programas que tengamos requerir\u00e1n ser reescritos. La librer\u00eda es compatible con este listado de chip y se ejecuta en una amplia gama de plataformas de Arduino y compatibles, incluidos los basados en AVR y ARM. La librer\u00eda presenta las siguientes caracter\u00edsticas: Soporte para modelo de color HSV asi como el cl\u00e1sico RGB. En Setting HSV Colors tenemos detalles del tema en ingl\u00e9s. La configuraci\u00f3n del brillo permite controlar, ademas del brillo, el uso de energia y por lo tanto la duraci\u00f3n de una posible bater\u00eda, si se utiliza. Funciones matem\u00e1ticas y de acceso a memoria hasta 10 veces mas r\u00e1pidas que las cl\u00e1sicas de Arduino. Para comenzar basta con descargar la librer\u00eda y comenzar a probar c\u00f3digo b\u00e1sico. Lo que vamos a ver a continuaci\u00f3n es la informaci\u00f3n b\u00e1sica sobre el uso de la librer\u00eda.","title":"Librer\u00eda FastLED"},{"location":"temas/matriz16x16/#configuracion-de-los-leds","text":"Cuando vamos a escribir c\u00f3digo necesitamos saber que LEDs estamos utilizando, cuantos hay y a que pin de salida de datos los vamos a conectar. Para los siguientes ejemplos trabajamos con una tira de 256 LEDs dispuestos en forma de matriz de 16x16 y los conectaremos al pin digital 3. Entra dentro de las buenas pr\u00e1cticas en programaci\u00f3n hacer el c\u00f3digo lo mas f\u00e1cil de leer que sea posible y que cuando necesitemos realizar cambios en las condiciones lo tengamos que hacer solamente en un lugar. Como ejemplo a continuaci\u00f3n vemos dos formas de escribir una l\u00ednea de c\u00f3digo FastLED.addLeds<4, 3>(leds, 256); // Forma 1 FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); // Forma 2 La Forma 1 utiliza n\u00fameros simples para definir las cosas mientras que la Forma 2 utiliza nombres, lo que hace al c\u00f3digo mas legible y si, por ejemplo queremos cambiar el n\u00famero de LEDs basta con hacerlo en la definici\u00f3n de NUM_LEDS. Dicho esto nuestras primeras l\u00edneas de c\u00f3digo van a ser: #include <FastLED.h> // Incluimos la librer\u00eda #define NUM_LEDS 256 // Definimos el n\u00famero de LEDs #define DATA_PIN 3 // Definimos el pin de datos CRGB leds[NUM_LEDS]; // Configura el bloque de memoria (matriz) para almacenar y manipular datos del LED El siguiente paso es configurar nuestros LEDs en el bucle inicializar o setup. Esto se hace como vemos a continuaci\u00f3n: void setup() { FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); } La l\u00ednea de configuraci\u00f3n indica que hay una tira de NEOPIXEL conectada al pin 3, que esos LEDs utilizaran la matriz leds y en el n\u00famero definido de 256. Si estamos utilizando chips de cuatro cables debemos cambiar esta l\u00ednea de configuraci\u00f3n para lo que consultaremos la documentaci\u00f3n original indicada en los enlaces.","title":"Configuraci\u00f3n de los LEDs"},{"location":"temas/matriz16x16/#encender-y-apagar-un-led","text":"El proceso de establecer un color para los LEDs se realiza estableciendo los valores de la matriz leds y posteriormente indicando a la biblioteca que muestre los datos. Por ejemplo, el siguiente c\u00f3digo enciende en verde el primer LED. void loop() { // Enciende el primer LED en verde leds[0] = CRGB::Green; FastLED.show(); delay(30); } El color es un tipo de dato enumerado (una lista de valores) que podemos consultar aqu\u00ed y que, como vemos en la animaci\u00f3n de la figura siguiente, se mostrar\u00e1n como opciones disponibles cuando tecleamos el color en la l\u00ednea de c\u00f3digo. Opciones de colores cuando tecleamos Apagar el LED consiste en ponerlo en color negro de forma similar a la vista anteriormente. El c\u00f3digo del programa completo Blynk es el siguiente: #include <FastLED.h> #define NUM_LEDS 256 #define DATA_PIN 3#include \"FastLED.h\" CRGB leds[60]; void setup() { FastLED.addLeds<NEOPIXEL, 6>(leds, 60); } void loop() { static uint8_t hue = 0; FastLED.showColor(CHSV(hue++, 255, 255)); delay(10); } CRGB leds[NUM_LEDS]; void setup() { FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); } void loop() { // Encender el primer LED en verde leds[0] = CRGB::Green; FastLED.show(); delay(1000); // Apagar el primer LED leds[0] = CRGB::Black; FastLED.show(); delay(1000); }","title":"Encender y apagar un LED"},{"location":"temas/matriz16x16/#ejemplos","text":"A continuaci\u00f3n vamos a ver diferentes ejemplos comentando en cada uno el concepto relativo a la librer\u00eda que se introduce y, como no, que hace el programa.","title":"Ejemplos"},{"location":"temas/matriz16x16/#encender-y-apagar-todos-los-pixeles","text":"Simplemente hacemos un bucle para recorrer la tira completa y ver como est\u00e1n conectados los LEDs. El programa ON_OFF_todos tiene el siguiente c\u00f3digo: #include <FastLED.h> #define NUM_LEDS 256 #define DATA_PIN 3 CRGB leds[NUM_LEDS]; void setup() { FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); } void loop() { for(int pixel=0; pixel<NUM_LEDS; pixel++){ leds[pixel] = CRGB::Blue; FastLED.show(); // Apagar el LED encendido para ver la siguiente iteracion del bucle leds[pixel] = CRGB::Black; delay(50); } }","title":"Encender y apagar todos los pixeles"},{"location":"temas/matriz16x16/#libreria-hsv","text":"La librer\u00eda proporciona una conversi\u00f3n r\u00e1pida de HSV a RGB ajustada a la percepci\u00f3n humana del color. Al definir colores con RGB, estamos mezclando los valores de color rojo, verde y azul. Cuando usamos HSV estamos definiendo el tono del color (es decir, d\u00f3nde est\u00e1 en la rueda de colores), qu\u00e9 tan saturado est\u00e1 y qu\u00e9 tan brillante es. Por ejemplo, el programa HSV_color recorrer\u00e1 los colores del arco\u00edris. #include <FastLED.h> #define NUM_LEDS 256 #define DATA_PIN 3 #define BRILLO 15 CRGB leds[NUM_LEDS]; void setup() { FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); FastLED.setBrightness(BRILLO); } void loop() { static uint8_t matiz = 0; FastLED.showColor(CHSV(matiz++, 255, 255)); delay(10); }","title":"Libreria HSV"},{"location":"temas/matriz16x16/#ejemplos-con-esp32-steamakers-tdr-steam","text":"En este apartado vamos a crear alg\u00fan ejemplo utilizando este conjunto de placas de las que podemos encontrar informaci\u00f3n en Notas sobre ESP32 STEAMakers . Tambi\u00e9n vamos a ver los ejemplos disponibles en la p\u00e1gina 16x16 RGB LED Panel Arduino Projects by coberfranc en Autodesk Instructables. Para instalar las placas ESP32, nos dirigimos a 'URLs adicionales de gestor de placas' disponible en 'Preferencias' y pegaremos la URL . Esto har\u00e1 que tengamos estas placas disponibles en el gestor de placas desde podemos instalarlas. Siempre vamos a partir de la base de que en el gestor de placas ya hemos instalado el Arduino Core for ESP32 de Espressif Systems tal y como vemos en la figura siguiente: esp32 instalado En la figura podemos tambi\u00e9n ver la selecci\u00f3n de placa y de puerto realizada.","title":"Ejemplos con ESP32 STEAMakers + TdR STEAM"},{"location":"temas/matriz16x16/#blink-con-led-rojo","text":"Vamos a comenzar por este sencillo ejemplo que nos servir\u00e1 para describir el entorno en el que vamos a programar. Analizando la documentaci\u00f3n vemos que el LED rojo est\u00e1 conectado al pin D12 que se corresponde con el pin IO19 o pin 19 de prop\u00f3sito general de entrada salida en la ESP32. El c\u00f3digo del programa lo tenemos a continuaci\u00f3n: void setup() { pinMode(19, OUTPUT); } void loop() { digitalWrite(19,HIGH); delay(1000); digitalWrite(19, LOW); delay(1000); }","title":"Blink con LED rojo"},{"location":"temas/matriz16x16/#encender-pixeles-con-potenciometro","text":"Vamos a tener el potenci\u00f3metro conectado al pin A0 de la TdR STEAM, que en la ESP32 es el pin IO02, y nos entregar\u00e1 un valor de 0 a 4095 (DAC de 12 bits). Utilizando la funci\u00f3n de mapeo convertimos ese rango de valores en un nuevo rango que ser\u00e1 el n\u00famero de LEDs. El pin que vamos a utilizar como salida de datos es el asociado al conector D3, que en la ESP32 es el pin IO25. El programa NLEDs_pot tiene el c\u00f3digo siguiente: #include <FastLED.h> #define NUM_LEDS_M 256 #define DATA_PIN 25 #define BRILLO 15 CRGB leds[NUM_LEDS_M]; void setup() { pinMode(DATA_PIN, OUTPUT); FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS_M); FastLED.setBrightness(BRILLO); } void loop() { int num = analogRead(2); int pixelesON = map(num, 0, 4095, 0, NUM_LEDS_M); FastLED.clear(); // Limpiamos la matriz for(int led = 0; led < pixelesON; led++) { leds[led] = CRGB::Purple; } FastLED.show(); } En el siguiente video vemos el funcionamiento del ejemplo:","title":"Encender pixeles con potenci\u00f3metro"},{"location":"temas/matriz16x16/#colores-aleatorios-en-el-panel","text":"Se trata del ejemplo 16random.ino en el que se van encendiendo de forma y en color aleatorio diferentes pixeles. Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: #include \"FastLED.h\" #define NUM_LEDS 256 #define DATA_PIN 25 CRGB leds[NUM_LEDS]; void setup() { delay(2000); FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS); FastLED.setBrightness(10); //Numero de 0 a 255 FastLED.clear(); } int random_integer; int random_integer2; void loop() { for(int i = 0; i <center 5; i++){ for(int j = 0; j <center 256; j++){ random_integer = (rand()%256)+1; random_integer2 = (rand()%256)+1; leds[random_integer].setHue(random_integer2); FastLED.show(); delay(100); } for(int k = 256; k > 0; k--){ leds[k] = CRGB::Black; } } } El video siguiente nos muestra el funcionamiento del ejemplo:","title":"Colores aleatorios en el panel"},{"location":"temas/matriz16x16/#paleta-de-colores-en-el-panel","text":"Se trata del ejemplo 16counter.ino en el que en un primer bucle que iteraciona tres veces se encienden todos los LEDs de uno en uno cambiando de color hasta que est\u00e1n todos encendidos que es cuando comienzan a apagarse de forma inversa. En otro bucle similar se encienden todos los LEDs pero de uno en uno tambi\u00e9n cambiando de color y comenzando las tres veces desde el principio. Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: #include \"FastLED.h\" #define NUM_LEDS 256 #define DATA_PIN 25 CRGB leds[NUM_LEDS]; void setup() { delay(2000); FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS); FastLED.setBrightness(10); //Number 0-255 FastLED.clear(); } int colorcalc; void loop() { colorcalc = 0; for(int i = 0; i < 3; i++){ for(int j = 0; j < 256; j++){ colorcalc = colorcalc + 1; leds[j].setHue(colorcalc);luces FastLED.show(); delay(20); } for(int j = 256; j > 0; j--){ leds[j] = CRGB::Black; FastLED.show(); delay(20);luces } } for(int i = 0; i < 3; i++){ for(int j = 0; j < 256; j++){ colorcalc = colorcalc + 1; leds[j].setHue(colorcalc); FastLED.show(); delay(20); leds[j] = CRGB::Black; FastLED.show(); } }luces } El video siguiente nos muestra el funcionamiento del ejemplo:","title":"Paleta de Colores en el panel"},{"location":"temas/matriz16x16/#pacman","text":"Se trata del ejemplo 16pacman.ino en el que se ver\u00e1 el cl\u00e1sico Pacman amarillo animado. El dise\u00f1o se ayuda de una tabla que act\u00faa a modo de plantilla. En la tabla se hace coincidir cada n\u00famero de celda con su n\u00famero de pixel correspondiente seg\u00fan la relaci\u00f3n de la figura siguiente: Plantilla 16x16 para dise\u00f1o luces El color negro de fondo representa el apagado de los LEDs. En la figura siguiente vemos el dise\u00f1o del cuerpo del Pacman Cuerpo del Pacman En la figura siguiente vemos el dise\u00f1o de la boca medio abierta. Boca medio abierta En la figura siguiente vemos el dise\u00f1o de la boca abierta. Boca abierta Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: #include \"FastLED.h\" #define NUM_LEDS 256luces #define DATA_PIN 25 CRGB leds[NUM_LEDS]; void setup() { delay(2000); FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS); FastLED.setBrightness(10); FastLED.clear(); } int eyes_seconds = 2;luces int reg_ghost_seconds = 10; int feet_delay = 220; int eye_loop = (eyes_seconds*1000)/feet_delay; int reg_ghost_loop = reg_ghost_seconds/eyes_seconds; int sad_ghost_loop = 50; int sad_ghost_blink_loop = 10; int body[] = { 5,6,7,8,9,10,19,20,21,22, 23,24,25,26,27,28,34,35,36,37, 38,39,40,41,42,43,44,45,49,50, 51,52,53,54,55,56,57,58,59,60, 61,62,65,66,67,68,69,70,71,72, 73,74,75,76,77,78,80,81,82,83, 84,85,86,87,88,89,90,91,92,93, 94,95,96,97,98,99,100,101,102,103, 104,105,106,107,108,109,110,111,112,113, 114,115,116,117,118,119,120,121,122,123, 124,125,126,127,128,129,130,131,132,133, 134,135,136,137,138,139,140,141,142,143, 144,145,146,147,148,149,150,151,152,153, 154,155,156,157,158,159,160,161,162,163, 164,165,166,167,168,169,170,171,172,173, 174,175,177,178,179,180,181,182,183,184, 185,186,187,188,189,190,193,194,195,196, 197,198,199,200,201,202,203,204,205,206, 210,211,212,213,214,215,216,217,218,219, 220,221,227,228,229,230,231,232,233,234, 235,236,245,246,247,248,249,250 }; int mouth_half_open[] = { 5,6,7,8,9,10,19,20,21,22, 23,24,25,26,27,28,35,36,37,38, 39,40,41,42,43,44,52,53,54,55, 56,57,58,59,68,69,70,71,72,73, 74,75,85,86,87,88,89,90,101,102, 103,104,105,106,118,119,120,121,134,135, 136,137,151,152 }; int mouth_open[] = {luces 5,6,7,8,9,10,19,20,21,22, 23,24,25,26,27,28,34,35,36,37, 38,39,40,41,42,43,44,45,49,50, 51,52,53,54,55,56,57,58,59,60, 61,62,65,66,67,68,69,70,71,72, 73,74,75,76,77,78,82,83,84,85, 86,87,88,89,90,91,92,93,99,100, 101,102,103,104,105,106,107,108,116,117, 118,119,120,121,122,123,133,134,135,136, 137,138,150,151,152,153luces }; int filler[] = { 138,116,117,107,108,84,83,82,78,77, 76,49,50,51,45,153,133,122,123,100, 99,91,92,93,67,66,65,60,61,62, 34 }; void loop() { for(int i = 0; i < reg_ghost_loop; i++){ for(int i = 0; i < eye_loop; i++){ //CUERPO for (int i = 0; i < 208; i++){ leds[body[i]] = CRGB::Yellow; } FastLED.show(); delay(200); //BOCA MEDIO ABIERTA for (int i = 0; i < 64; i++){ leds[mouth_half_open[i]] = CRGB::Black; } FastLED.show(); delay(200); //BOCA ABIERTA for (int i = 0; i < 96; i++){ leds[mouth_open[i]] = CRGB::Black; } FastLED.show(); delay(200); //CUERPO for (int i = 0; i < 31; i++){ leds[filler[i]] = CRGB::Yellow; } FastLED.show(); delay(200); } } } El video siguiente nos muestra el funcionamiento del ejemplo:","title":"Pacman"},{"location":"temas/matriz16x16/#remolino-de-colores","text":"Se trata del ejemplo 16colormatrix.ino en el que se aplican funciones auxiliares para una matriz XY bidimensional. La funci\u00f3n XY(x,y) toma las coordenadas 'x e y' y devuelve el n\u00famero de \u00edndice LED, para usarla debemos invocarla as\u00ed: leds[ XY(x,y) ] == CRGB::Red; Esta funci\u00f3n no realiza ninguna comprobaci\u00f3n de errores. La funci\u00f3n XYsafe(x,y) toma las coordenadas 'x e y' y devuelve el n\u00famero de \u00edndice LED, para usarla debemos invocarla as\u00ed: leds[ XYsafe(x,y) ] == CRGB::Red; La verificaci\u00f3n de errores se realiza en los rangos de x e y, y se devuelve un \u00edndice de \"-1\". Tambi\u00e9n se define un par\u00e1metro para diferenciar la forma en que est\u00e1n conectados los LEDs que en los comentarios del ejemplo original indican lo siguiente: \" Vocabulario adicional: cualquier cosa que vaya en una direcci\u00f3n en una fila, y luego hacia atr\u00e1s en la fila siguiente, y as\u00ed sucesivamente, se llama \" Bustrofedon \", que significa \"como ara el buey\". \" Esta funci\u00f3n devolver\u00e1 el 'n\u00famero de \u00edndice de led' para un conjunto dado de coordenadas X e Y en la matriz si lo indicamos de manera correcta, es decir, la funci\u00f3n no controla LOS L\u00cdMITES DE COORDENADAS, as\u00ed que no debemos pasarle valores falsos. Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: #include <FastLED.h> #define LED_PIN 25 #define COLOR_ORDER GRB #define CHIPSET WS2812B #define BRIGHTNESS 10 // Parametros de anchura y altura const uint8_t kMatrixWidth = 16; const uint8_t kMatrixHeight = 16; // Parametro para diferenciar la forma de conexionado de los LEDs: // La ponemos a false si los pixeles est\u00e1n dispuestos como una tira // la ponemos a true si est\u00e1n dispuestos en zig-zag const bool kMatrixSerpentineLayout = true; uint16_t XY( uint8_t x, uint8_t y) { uint16_t i; if( kMatrixSerpentineLayout == false) { i = (y * kMatrixWidth) + x; } if( kMatrixSerpentineLayout == true) { if( y & 0x01) { // Odd rows run backwards uint8_t reverseX = (kMatrixWidth - 1) - x; i = (y * kMatrixWidth) + reverseX; } else { // Even rows run forwards i = (y * kMatrixWidth) + x; } } return i; } #define NUM_LEDS (kMatrixWidth * kMatrixHeight) CRGB leds_plus_safety_pixel[ NUM_LEDS + 1]; CRGB* const leds( leds_plus_safety_pixel + 1); void setup() { FastLED.addLeds<CHIPSET, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection(TypicalSMD5050); FastLED.setBrightness( BRIGHTNESS ); } uint16_t XYsafe( uint8_t x, uint8_t y) { if( x >= kMatrixWidth) return -1; if( y >= kMatrixHeight) return -1; return XY(x,y); } void loop() { uint32_t ms = millis(); int32_t yHueDelta32 = ((int32_t)cos16( ms * (27/1) ) * (350 / kMatrixWidth)); int32_t xHueDelta32 = ((int32_t)cos16( ms * (39/1) ) * (310 / kMatrixHeight)); DrawOneFrame( ms / 65536, yHueDelta32 / 32768, xHueDelta32 / 32768); if( ms < 5000 ) { FastLED.setBrightness( scale8( BRIGHTNESS, (ms * 256) / 5000)); } else { FastLED.setBrightness(BRIGHTNESS); } FastLED.show(); } void DrawOneFrame( byte startHue8, int8_t yHueDelta8, int8_t xHueDelta8) { byte lineStartHue = startHue8; for( byte y = 0; y < kMatrixHeight; y++) { lineStartHue += yHueDelta8; byte pixelHue = lineStartHue; for( byte x = 0; x < kMatrixWidth; x++) { pixelHue += xHueDelta8; leds[ XY(x, y)] = CHSV( pixelHue, 255, 255); } } } En el siguiente video vemos el funcionamiento del ejemplo:","title":"Remolino de colores"},{"location":"temas/matriz16x16/#fantasma-pacman-en-rojo","text":"Se trata del ejemplo 16red.ino en el que se dibuja un fantasma de color rojo del juego PACMAN y se hace que mueva los ojos a izquierda y derecha y tambi\u00e9n que mueva los pies. El dise\u00f1o se ayuda de una tabla que act\u00faa a modo de plantilla. En la tabla se hace coincidir cada n\u00famero de celda con su n\u00famero de pixel correspondiente seg\u00fan la relaci\u00f3n de la figura siguiente: Plantilla 16x16 para dise\u00f1o El color negro de fondo representa el apagado de los LEDs. En la figura siguiente vemos el dise\u00f1o del fantasma mirando a su izquierda. Fantasma mirando a su izquierda En la figura siguiente vemos el dise\u00f1o del fantasma mirando a su derecha. Fantasma mirando a su derecha Este es el c\u00f3digo adaptado a ESP32 STEAMaker + TdR STEAM: //FANTASMA PACMAN ANIMADO #include \"FastLED.h\" #define NUM_LEDS 256 #define DATA_PIN 25 CRGB leds[NUM_LEDS]; void setup() { delay(2000); FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS); FastLED.setBrightness(10); //Numero entero entre 0 y 255 FastLED.clear(); } int body[] = { 0,1,2,3,4,5,6,7,21,22, 23,24,25,26,27,28,29,30,31,32, 33,34,35,36,37,38,39,40,41,42, 43,51,52,53,54,55,56,57,58,59, 60,61,62,63,64,65,66,67,68,69, 70,71,72,73,74,75,76,77,81,82, 83,84,85,86,87,88,89,90,91,92, 93,94,95,96,97,98,99,100,101,102, 103,104,105,106,107,108,109,110,113,114, 115,116,117,118,119,120,121,122,123,124, 125,126,127,128,129,130,131,132,133,134, 135,136,137,138,139,140,141,142,145,146, 147,148,149,150,151,152,153,154,155,156, 157,158,159,160,161,162,163,164,165,166, 167,168,169,170,171,172,173,174,178,179, 180,181,182,183,184,185,186,187,188,189, 190,191,192,193,194,195,196,197,198,199, 200,201,202,203,204,212,213,214,215,216, 217,218,219,220,221,222,223,224,225,226, 227,228,229,230,231,232,233,234,248,249, 250,251,252,253,254,255 }; int eyes_left[] = { 54,55,56, 70,71,72,73,74, 85,86,87,88,89, 103,104,105, 150,151,152, 166,167,168,169,170, 181,182,183,184,185, 199,200,201}; int eyes_right[] = { 71,72,73, 85,86,87,88,89, 102,103,104,105,106, 118,119,120, 169,168,167, 181,182,183,184,185, 202,201,200,199,198, 214,215,216}; int eyes_fill_body[] = { 149,150,151,152,153,53,54,55,56,57}; //eliminar pixeles alrededor de los pies int void_pixels_1[] = {8, 29, 30, 31, 83, 84, 85, 86, 138, 139, 140, 161}; int void_pixels_2[] = {7, 31, 55, 56, 57, 112, 113, 114, 138, 162}; int feet_fill_body[] = { 224,222,129,128,63,33}; int sad_ghost[] = {11, 26, 35, 48, 49, 53, 60, 64, 65, 80, 89, 104, 105, 109, 116, 120, 121, 134, 143, 158}; int eyes_seconds = 2; int reg_ghost_seconds = 10; int feet_delay = 220; int eye_loop = (eyes_seconds*1000)/feet_delay; // cuanto tiempo mira a izquierda y derecha int reg_ghost_loop = reg_ghost_seconds/eyes_seconds; int sad_ghost_loop = 50; int sad_ghost_blink_loop = 10; int pupil_right[] = { 151,152, 168,167, 72,71, 55,56}; int pupil_left[] = { 215,216, 200,199, 119,120, 104,103}; int feet_left[] = { 222,224,223,192, 129,126,128,127, 33,63,32,31}; int feet_right[] = { 255, 190,191,192,160, 65,64,63,95, 0}; int feet_fill[] = { 31,32,33, 224,223,222, 129,128,126,127}; int feet_fill2[] = { 31,32,33, 224,223,222, 129,128,126,127}; int feet_clear[] = { 254,225,222,193,190,161,158,129,126,97,94,65,62,33,30,1, 255,224,223,192,191,160,159,128,127,96,95,64,63,32,31,0 }; void loop() { for(int i = 0; i < reg_ghost_loop; i++){ for(int i = 0; i < eye_loop; i++){ //Cuerpo for (int i = 0; i < 206; i++){ leds[body[i]] = CRGB::Green; } //Ojos for (int i = 0; i < 32; i++){ leds[eyes_left[i]] = CRGB::White; } //Pupilas for (int i = 0; i < 8; i++){ leds[pupil_right[i]] = CRGB::DarkBlue; } FastLED.show(); //Pies for(int i = 0; i < 2; i++){ //configura pie for (int i = 0; i < 12; i++){ leds[feet_left[i]] = CRGB::Black; } FastLED.show(); delay(feet_delay); //configura pie for (int i = 0; i < 12; i++){ leds[feet_right[i]] = CRGB::Black; } for (int i = 0; i < 10; i++){ leds[feet_fill[i]] = CRGB::Green; } FastLED.show(); delay(feet_delay); for (int i = 0; i < 32; i++){ leds[feet_clear[i]] = CRGB::Green; } } //fin bucle pies //Cambio ojos //Cuerpo for (int i = 0; i < 206; i++){ leds[body[i]] = CRGB::Green; } //Ojos for (int i = 0; i < 32; i++){ leds[eyes_right[i]] = CRGB::White; } //Pupilas for (int i = 0; i < 8; i++){ leds[pupil_left[i]] = CRGB::DarkBlue; } FastLED.show(); //Pie for(int i = 0; i < 2; i++){ //configura pie for (int i = 0; i < 12; i++){ leds[feet_left[i]] = CRGB::Black; } FastLED.show(); delay(feet_delay); //configura pie for (int i = 0; i < 12; i++){ leds[feet_right[i]] = CRGB::Black; } for (int i = 0; i < 10; i++){ leds[feet_fill[i]] = CRGB::Green; } FastLED.show(); delay(feet_delay); for (int i = 0; i < 32; i++){ leds[feet_clear[i]] = CRGB::Green; } } //fin bucle pies } //fin bucle ojos } //fin bucle fantasma } En el siguiente video vemos el funcionamiento del ejemplo:","title":"Fantasma PACMAN en rojo"},{"location":"temas/matriz8x32/","text":"Matriz o panel de 8x32 \u00b6 Descripci\u00f3n \u00b6 En realidad se trata de tiras de 256 LEDs dispuestos en forma de panel o matriz que tienen el aspecto de la figura siguiente: Aspecto de una matriz de 8x32 Podemos observar que este tipo de paneles son, hasta cierto punto, flexibles y que permiten utilizar el concepto de apilado o encadenado conectando la salida de uno a la entrada del otro. En principio la \u00fanica limitaci\u00f3n de conexionado va a estar en la capacidad de entregar la corriente que demande la configuraci\u00f3n de paneles. Referente al tema de la alimentaci\u00f3n hemos de tener presente que cada uno de los LEDs puede consumir hasta 60 mA (20 mA cada color) si combinamos los colores a m\u00e1ximo brillo para obtener un color blanco intenso, por lo que el consumo m\u00e1ximo puede ser de: I\\_max = 8 \\cdot32 \\cdot 60 = 15.360\\space mA I\\_max = 8 \\cdot32 \\cdot 60 = 15.360\\space mA Es decir, que en las condiciones indicadas un panel puede llegar a consumir por encima de 15A, lo que nos indica claramente que tampoco est\u00e1n dise\u00f1ados para trabajar de esta forma. En condiciones de brillo por debajo de 100 y los LEDs cambiando su estado (por ejemplo en un letrero que se desplaza) un panel se puede alimentar desde el conector de entrada que tiene 3 pines: DIN, 5V y GND. Los LEDs WS2812 que se utilizan son de 4 pines que se distribuyen en cada LED como vemos en la figura siguiente: Pines LED WS2812 El panel o matriz que vamos a utilizar conecta los LEDs como vemos en la figura siguiente: Panel con conexi\u00f3n en linea La parte posterior de este panel tiene el aspecto de la figura siguiente: Parte posterior del panel Aunque debemos tener presente que los LEDs se pueden conectar de cualquiera de las formas que vemos en la figura siguiente: Conexiones en zig zag y en linea Programaci\u00f3n con ArduinoBlocks \u00b6 Bloques \u00b6 En la figura siguiente vemos el men\u00fa bloques disponible en 'Visualizaci\u00f3n' en su entrada 'NeoPixel'. Bloques LEDs RGB direccionables Ya hemos indicado que la disposici\u00f3n en forma de matriz no implica que el conexionado de los LEDs est\u00e9 realizado de esa forma, sino que est\u00e1n conectados como si de una tira se tratase y por ello los bloques tipo matriz no van a servirnos de mucha ayuda en la programaci\u00f3n de estos elementos, y por eso se han puesto difuminados. Para demostrar esto se anima al lector a analizar el posible resultado de un simple programa como el de la figura siguiente: Ejemplo para demostrar que no se programa como matriz Si cargamos el programa Ej_no_matriz.abp en nuestra placa y lo hacemos funcionar con el panel conectado podremos observar como su comportamiento nada tiene que ver con el esperado. Ejemplos de uso \u00b6 Vamos a ver una serie de ejemplos de uso del panel tratado como tira de LEDs direccionables para ver que as\u00ed funciona perfectamente. A1. Encender y apagar todos los LEDs . En esta primera actividad vamos a establecer un nivel de brillo lo suficientemente bajo (15) como para que cuando se enciendan todos los LEDs nuestro USB no se desconecte por exceso de consumo. Si queremos trabajar con brillos mayores basta con alimentar el panel a trav\u00e9s de los cables destinados a ello con una fuente de alimentaci\u00f3n adecuada, pero recordemos el consumo m\u00e1ximo que pueden llegar a tener si los ponemos todos a m\u00e1ximo brillo y en blanco, que supera los 15A. Por otro lado en el bucle de encendido hemos dado un peque\u00f1o retardo que demuestra claramente como est\u00e1n conectados los LEDs. En el enlace tenemos el programa A1. Encender y apagar todos los LEDs siguiente: A1. Encender y apagar todos los LEDs A2. Encender todos desplazando el LED encendido . Se trata del mismo bucle que en la actividad anterior pero en esta ocasi\u00f3n borramos los datos en cada iteraci\u00f3n haciendo as\u00ed que solamente se encienda un LED. En el enlace tenemos el programa A2. Encender todos desplazando el LED encendido siguiente: A2. Encender todos desplazando el LED encendido A3. Encender pares e impares con color aleatorio . Con un bucle encendemos los LEDs de color par despu\u00e9s de llamar a la funci\u00f3n que establece de forma aleatoria los valores RGB, con otro hacemos lo mismo pero con los impares y finalmente con otro bucle los apagamos todos durante un tiempo. En el enlace tenemos el programa A3. Encender pares e impares con color aleatorio siguiente: A3. Encender pares e impares con color aleatorio De esta forma podemos seguir haciendo cosas con el panel pero la verdad es que salvo la disposici\u00f3n de los LEDs no se ven muchas mas posibilidades Trabajo con la herramienta Neopixel - Matrix data \u00b6 Accedemos a ella a trav\u00e9s el men\u00fa herramientas, tal y como vemos en la animaci\u00f3n de la figura siguiente. Observamos como establecer el tipo de matriz seg\u00fan est\u00e9n conexionados los LEDs en l\u00ednea o zig zag y simplemente se han pintado algunos pixeles de diferentes colores a modo de ejemplo. Herramienta Neopixel - Matrix data Ejemplo de uso de la herramienta Neopixel - Matrix data Mostrar ese dise\u00f1o en la matriz es tan sencillo como hacer un programa como el de la figura siguiente. Ejemplo de uso de la herramienta Neopixel - Matrix data Hemos copiado los datos generados en el bloque 'Establecer datos'. Es posible realizar dise\u00f1os mas complejos con esta herramienta, como por ejemplo escribir textos, pero nos vamos a encontrar que es un trabajo bastante complejo, lento y tedioso al que adem\u00e1s se a\u00f1ade una dificultad, y es que el dise\u00f1o en pantalla est\u00e1 en posici\u00f3n espejo (como si se reflejase en uno) respecto a la posici\u00f3n real de los diodos del panel del que dispongo. Un ejemplo, con alg\u00fan peque\u00f1o error que no se ha corregido a prop\u00f3sito, como el que vemos en el v\u00eddeo siguiente ha costado algo mas de una hora llevarlo a cabo.Adafruit_NeoMatrix Tambi\u00e9n existe una herramienta de generaci\u00f3n de los datos a partir de una imagen, pero esta debe tener una resoluci\u00f3n similar a la del panel para que obtengamos algo viable. En la imagen siguiente vemos el resultado obtenido a partir de la imagen original de la izquierda y vemos que se parecen en poco o nada. Ejemplo de uso de la herramienta Neopixel - Matrix data Aunque podemos crear efectos y alguna cosa mas parece evidente que hoy por hoy (enero de 2023) no se trabaja con eficiencia en ArduinoBlocks con este tipo de elementos. Vamos a ver a continuaci\u00f3n como hacerlo de una mejor manera utilizando el IDE de Arduino y las librer\u00edas necesarias para su funcionamiento. Librer\u00edas \u00b6 Para un correcto funcionamiento vamos a necesitar las siguientes bibliotecas: Adafruit_GFX Adafruit_NeoMatrix Adafruit_NeoPixel Si no las tenemos instaladas procedemos a su descarga de los enlaces anteriores y a su instalaci\u00f3n siguiendo el proceso descrito en el punto \"Gestor de librer\u00edas\" del apartado IDE 2 . Si estamos utilizando un IDE anterior a la versi\u00f3n (1.8.10) tambi\u00e9n debemos tener instalada la librer\u00eda BusIO . Por lo tanto, todos nuestros programas o sketches deben incluir como cabecera las tres l\u00edneas de c\u00f3digo siguientes: #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> Librer\u00eda GFX \u00b6 Se trata de una librer\u00eda que nos proporciona un conjunto de funciones gr\u00e1ficas que incluyen l\u00edneas, c\u00edrculos y texto y que se utilizan de forma habitual en pantallas LCD y OLED. Utiliza un sistema de coordenadas y unidades que permiten referenciar cada pixel a partir de un punto o coordenada de origen (0,0) que se sit\u00faa en la esquina superior izquierda, de manera que X es positivo hacia la derecha e Y hac\u00eda abajo. Es posible aplicar hasta cuatro rotaciones para indicar que esquina de la pantalla representa la parte superior izquierda. Las coordenadas siempre se expresan en pixeles, lo que implica que no existe una escala de medida real como el mil\u00edmetro, y por lo tanto el tama\u00f1o de un determinado gr\u00e1fico es funci\u00f3n del tama\u00f1o del punto o de la densidad de pixeles de la pantalla en la que se muestra. El n\u00famero de puntos de una pantalla se suele indicar en su datasheet o bien calcular midiendo el ancho de la misma y dividiendo por la cantidad de pixeles. Aunque cada pantalla concreta va a disponer de sus propias funciones constructoras e inicializadoras existen una serie de prototipos que son: Dibujar pixles (puntos) . Lo m\u00e1s b\u00e1sico que podemos dibujar en una pantalla es un punto a partir de especificar su coordenada X,Y y su color: void drawPixel (uint16_t x, uint16_t y, uint16_t color); Dibujar l\u00edneas . Debemos especificar el punto inicial, el punto final y el color: void drawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t color); Si se trata de l\u00edneas horizontales o verticales tenemos las dos funciones siguientes: void drawFastVLine(uint16_t x0, uint16_t y0, uint16_t length, uint16_t color); // Vertical void drawFastHLine(uint8_t x0, uint8_t y0, uint8_t length, uint16_t color); // Horizontal Rect\u00e1ngulos . Se pueden crear cuadrados o rect\u00e1ngulos, que se pueden rellenar o no, utilizando los siguientes procedimientos: void drawRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color); void fillRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color); La anchura se especifica en las coordenadas X y la altura se especifica en las coordenadas Y. C\u00edrculos . Tambi\u00e9n los c\u00edrculos se pueden rellenar y dibujar indicando en este caso el centro el primer par X,Y y el radio el segundo par X,Y. Los procedimientos son: void drawCircle(uint16_t x0, uint16_t y0, uint16_t r, uint16_t color); void fillCircle(uint16_t x0, uint16_t y0, uint16_t r, uint16_t color); Rect\u00e1ngulos redondeados . Tambi\u00e9n pueden dibujarse y rellenarse. En primer lugar se indican el ancho y el alto como en rect\u00e1ngulos normales, luego se indica el radio de las esquinas (en pixeles) y finalmente se indica el color. void drawRoundRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t radius, uint16_t color); void fillRoundRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t radius, uint16_t color); Tri\u00e1ngulos . De nuevo est\u00e1 disponible la opci\u00f3n de relleno. En esta ocasi\u00f3n se requieren un par de coordenadas para cada v\u00e9rtice seguidas de un color: void drawTriangle(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color); void fillTriangle(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color); Caracteres y texto . Si queremos a\u00f1adir un solo car\u00e1cter indicamos la coordenada donde lo posicionamos, el color y el color de fondo. Opcionalmente se puede a\u00f1adir otro par\u00e1metro para escalar la fuente en un determinado factor, por ejemplo size=2 pondr\u00e1 la fuente en un tama\u00f1o de 10x16 pixeles. void drawChar(uint16_t x, uint16_t y, char c, uint16_t color, uint16_t bg, uint8_t size); Para escribir una cadena lo que se hace es configurar los par\u00e1metros en procedimientos separados y finalmente se usa la funci\u00f3n 'print()' o bien 'println' , como vemos a continuaci\u00f3n: void setCursor(int16_t x0, int16_t y0); void setTextColor(uint16_t color); void setTextColor(uint16_t color, uint16_t backgroundcolor); void setTextSize(uint8_t size); void setTextWrap(boolean w); println(\"Hola\"); void setTextSize(2); println(\"4321.98); void setTextSize(3); println(0xABCDEFG, HEX);void fillScreen(uint16_t color); Comienza con setCursor(x, y) , que sit\u00faa la esquina superior izquierda del texto, por defecto es (0,0), luego establecemos el color del texto con setTextColor(color), que por defecto es blanco. El texto normalmente se dibuja en color \"claro\" pero si queremos se puede especificar un color de fondo como segundo par\u00e1metro opcional para setTextColor(). Finalmente, setTextSize(size) multiplicar\u00e1 la escala del texto por un factor entero dado. De forma predeterminada, las l\u00edneas largas de texto est\u00e1n configuradas para \"ajustarse\" autom\u00e1ticamente a la columna m\u00e1s a la izquierda. Para anular este comportamiento se utiliza 'setTextWrap(false)' . El comportamiento de ajuste normal se restaura con 'setTextWrap(true)' . Mapas de bits . Es posible dibujar mapas de bits monocrom\u00e1ticos. void drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h, uint16_t color); Esto crea un bloque contiguo de bits en la pantalla, donde cada bit '1' ilumina el p\u00edxel correspondiente en 'color', mientras que se omite cada bit '0'. las coordenadas x,y fijan la esquina superior izquierda donde se dibuja el mapa de bits, w, h son el ancho y el alto en p\u00edxeles. Los datos del mapa de bit deben estar en la memoria de programa. Limpiar o rellenar la pantalla . Se trata de una funci\u00f3n que configura toda la pantalla en un color dado. Si el color es negro equivale a borrarla ya que todos los LEDs se ponen en negro, es decir se apagan. void fillScreen(uint16_t color); Librer\u00eda NeoPixel \u00b6 Esta es la librer\u00eda que hemos venido utilizando en ArduinoBlocks para trabajar con el panel como tira de LEDs direccionables. Para trabajar con tiras de LEDs son necesarias las siguientes tres l\u00edneas de c\u00f3digo: #define LED_PIN 6 // Pin de datos #define LED_COUNT 60 // Numero de LEDs de la tira // Declaraci\u00f3n del objeto NeoPixel strip: Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800); Los par\u00e1metros o argumentos del objeto para una funci\u00f3n como Adafruit_NeoPixel neo_pixel = Adafruit_NeoPixel(256,2,NEO_GRB+NEO_KHZ800); son los siguientes: 1: N\u00famero de p\u00edxeles en la tira. LED_COUNT = 256 2: N\u00famero de pin de Arduino. LED_PIN = 2 3: Indicadores de tipo de p\u00edxel, la suma ser\u00e1 alguna de estas combinaciones: NEO_KHZ800 Flujo de bits de 800 KHz (la mayor\u00eda de los productos se hacen con LEDs WS2812) NEO_KHZ400 400 KHz (p\u00edxeles FLORA cl\u00e1sicos 'v1' (no v2), controladores WS2811) Los p\u00edxeles NEO_GRB est\u00e1n cableados para flujo de bits GRB (la mayor\u00eda de los productos) Los p\u00edxeles NEO_RGB est\u00e1n cableados para flujo de bits RGB (p\u00edxeles FLORA v1 , no v2) Los p\u00edxeles NEO_RGBW est\u00e1n cableados para el flujo de bits RGBW (productos NeoPixel RGBW) Existen diferentes funciones para manejo de una tira de LEDs que no vamos a definir aqu\u00ed pues ya est\u00e1n definidas en ArduinoBlocks. Librer\u00eda NeoMatrix \u00b6 Se trata de una biblioteca o librer\u00eda de Adafruit , basada en NeoPixel, que permite crear pantallas gr\u00e1ficas bidimensionales utilizando los paneles que estamos viendo. Esto nos va a permitir dibujar f\u00e1cilmente formas, texto y animaciones sin tener que calcular la posici\u00f3n XY de cada p\u00edxel. NeoMatrix de Adafruit utiliza el mismo sistema de coordenadas, funciones de color y comandos gr\u00e1ficos que la biblioteca GFX que hemos visto. Vamos a centrar nuestra atenci\u00f3n en c\u00f3mo declarar una pantalla bidimensional hecha a partir de LEDs direccionables o NeoPixels. La librer\u00eda o biblioteca es capaz de manejar tanto matrices individuales (todos los LEDs en una sola cuadr\u00edcula uniforme) como matrices en mosaico (m\u00faltiples cuadr\u00edculas combinadas en una pantalla m\u00e1s grande): Matrices simples o agrupadas El siguiente paso es invocar a la directiva del preprocesador #ifndef para comprobar si la macro PSTR est\u00e1 definida. Esta macro (definida en pgmspace.h ) sirve para declarar cadenas flash en un bloque de c\u00f3digo para escribir y leer en la memoria de programa PROGMEM. Esto es conveniente hacerlo porque la librer\u00eda utiliza la correcci\u00f3n gamma del color para minimizar el consumo. El c\u00f3digo ahora estar\u00eda as\u00ed: #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> #ifndef PSTR #define PSTR #endif Con esto estamos en condiciones de crear la declaraci\u00f3n de nuestra matriz, lo que se hace mediante la siguiente l\u00ednea de c\u00f3digo: Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(WIDTH, HEIGTH, Hor, Ver, PIN, matrix_layout_flags); Con esto invocamos al constructor para que nos cree el elemento 'matriz' con los par\u00e1metros definidos entre par\u00e9ntesis y separados por comas y que vamos a explicar a continuaci\u00f3n: Par\u00e1metro 1, WIDTH : Define el ancho de la matriz individual o de cada matriz en una agrupaci\u00f3n (no del total de la pantalla) Par\u00e1metro 2, HEIGTH : Define la altura de la matriz individual o de cada matriz en una agrupaci\u00f3n Par\u00e1metro 3, Hor : N\u00famero de matrices conectadas horizontalmente Par\u00e1metro 4, Ver : N\u00famero de matrices conectadas verticalmente Par\u00e1metro 5, PIN : N\u00famero de pin que usaremos como salida de datos de nuestra placa y que ir\u00e1 conectado a la entrada DIN de la matriz. Par\u00e1metro 6, matrix_layout_flags : Aqu\u00ed es donde tenemos que definir las banderas o flags de dise\u00f1o de nuestra matriz o pantalla (agrupaci\u00f3n de matrices) y se hace sumando todos los que necesitemos de los siguientes: Posici\u00f3n del primer LED de la primera matriz: NEO_MATRIX_TOP, NEO_MATRIX_BOTTOM, NEO_MATRIX_LEFT, NEO_MATRIX_RIGHT Por ejemplo: NEO_MATRIX_TOP + NEO_MATRIX_LEFT para esquina superior izquierda Disposici\u00f3n de los LEDs en cada matriz: NEO_MATRIX_ROWS, NEO_MATRIX_COLUMNS: Elegimos uno u otro Forma de conexionado de filas/columnas: NEO_MATRIX_PROGRESSIVE, NEO_MATRIX_ZIGZAG: Elegimos uno Posici\u00f3n de la primera matriz en un mosaico: NEO_TILE_TOP, NEO_TILE_BOTTOM, NEO_TILE_LEFT, NEO_TILE_RIGHT Por ejemplo: NEO_TILE_TOP + NEO_TILE_LEFT para esquina superior izquierda Disposici\u00f3n de las matrices en la pantalla: NEO_TILE_ROWS, NEO_TILE_COLUMNS: Elegimos uno u otro Tipo de matriz: NEO_RGB, para pixeles V1 con flujo de datos (bitstream) RGB NEO_GRB, para pixeles V2 con flujo de datos (bitstream) GRB NEO_KHZ400, para bitstream de 400 KHz (por ejemplo pixeles FLORA V1) NEO_KHZ800, para bitstream de 800 KHz (por ejemplo tiras de alta densidad de LEDs) Nuestro c\u00f3digo podr\u00eda continuar, por ejemplo, de la forma siguiente: #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> #ifndef PSTR #define PSTR #endif #define PIN 3 Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(32, 8, 2, 1, PIN, NEO_TILE_TOP + NEO_TILE_LEFT + NEO_TILE_ROWS + NEO_TILE_PROGRESSIVE + NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); El constructor de la matriz nos facilita la siguiente informaci\u00f3n de ayuda: Ayuda del constructor Observamos como los par\u00e1metros 1 al 5 deben ser n\u00fameros enteros positivos de 8 bits, es decir, hasta 255. Un ejemplo de definici\u00f3n de una matriz de 32x8 en un solo panel podr\u00eda ser como sigue: Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(32, 8, PIN, NEO_MATRIX_TOP + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_PROGRESSIVE, NEO_GRB + NEO_KHZ800); El resto de tareas las vamos a ver utilizando un ejemplo comentado en el que usamos una pantalla de 64x8 pixeles formada a partir de 2 matrices de 32x8 pixeles en la que vamos a hacer que un texto se desplace cmabiando en cada iteraci\u00f3n el color de las letras entre 8 posibles combinaciones. El ejemplo NavidadConCiencia que puedes descargar del enlace tiene el siguiente c\u00f3digo: // Invocamos librer\u00edas #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> // Definimos patilla de salida de datos #define PIN 3 //Creamos el objeto matriz Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, 2, 1, PIN, NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); // Definimos vectores de colores const uint16_t colors[] = { matriz.Color(255, 0, 0), matriz.Color(0, 255, 0), matriz.Color(255, 255, 0), matriz.Color(0, 0, 255), matriz.Color(255, 0, 255), matriz.Color(0, 255, 255), matriz.Color(255, 128, 0), matriz.Color(255, 255, 255)}; void setup() { matriz.begin(); // Iniciamos el objeto matriz.setTextWrap(false); // Relativo a si se recorta o no el texto si es mayor que la matriz matriz.setBrightness(15); // Establece el brillo en un 15% matriz.setTextColor(colors[0]); // Se establece el primer color como inicial } int x = matriz.width(); // Calculo de la anchura de la matriz int pases = 0; // Pasadas para el cambio de color void loop(){ matriz.fillScreen(0); //Apaga todos los LEDs matriz.setCursor(x, 0); // Coloca el cursor en la posici\u00f3n 64,0 en este caso concreto char cadena[] = \"Parque de las Ciencias - openLAB - Club Robotica Granada\"; // Cadena a mostrar int longitud_cadena = strlen(cadena); // N\u00famero de caracteres de la cadena int longitud_pixels = longitud_cadena * 6; // Cada caracter ocupa 5 pixeles mas un espacio, en total 6 pixeles matriz.print((cadena)); // Mostrar la cadena if( --x < -longitud_pixels ) // Decremento de la posici\u00f3n X en funci\u00f3n de la variable { x = matriz.width(); // Reiniciamos la variable if(++pases >= 8) pases = 0; // Comprobamos si hemos llegado al \u00faltimo vector de color matriz.setTextColor(colors[pases]); // Establce el color seg\u00fan el \u00edndice del vector } matriz.show(); // Muestra la pantalla delay(100); } La declaraci\u00f3n del objeto matriz tambi\u00e9n se puede hacer de la forma siguiente: Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(64, 8, PIN, NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); En el video siguiente podemos ver el resultado de este programa. Dibujos b\u00e1sicos \u00b6 Veremos ejemplos simples de uso de la librer\u00eda para crear dibujos sencillos como dibujar un pixel, un cuadrado relleno o no, l\u00edneas, c\u0155culos rellenos o no y como poner un texto fijo. Pixeles y cuadrados \u00b6 Lo m\u00e1s sencillo que podemos dibujar es un pixel de un color determinado y para ello basta con invocar el siguiente comando: // dibujar un pixel de color blanco matriz.drawPixel(x, y, matrix.Color(R, G, B)); Para dibujar un contorno rectangular relleno haremos lo siguiente: // dibujar un rectangulo s\u00f3lido matriz.fillRect(xi, yi, xrf, yrf, matrix.Color(R, G, B)); Damos las coordenadas del v\u00e9rtice inicial y las del opuesto en su diagonal, siendo estas \u00faltimas relativas pues se cuentan a partir de las iniciales. Para dibujar el contorno de un rectangulo haremos lo siguiente: // dibujar un rectangulo matriz.drawRect(xi, yi, xrf, yrf, matrix.Color(R, G, B)); En el ejemplo siguiente se dibujan los cuatro pixeles centrales en color blanco, un rect\u00e1ngulo relleno, un rect\u00e1ngulo, otro rect\u00e1ngulo perimetral, un rect\u00e1ngulo que rodea a los pixeles y finalmente otro rect\u00e1ngulo s\u00f3lido de color rojo en el interior del rect\u00e1ngulo verde. // Invocamos librer\u00edas #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> // Definimos patilla de salida de datos #define PIN 3 //Creamos el objeto matriz Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN, NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); void setup() { matriz.begin(); // Iniciamos el objeto### <FONT COLOR=#AA0000>L\u00edneas y circulos</font> matriz.setBrightness(15); // Establece el brillo en un 15% } int x = matriz.width(); // Calculo de la anchura de la matriz void loop(){ matriz.fillScreen(0); //Apaga todos los LEDs delay(1000); matriz.show(); matriz.setCursor(x, 0); // Coloca el cursor en la posici\u00f3n 31,0 en este caso concreto // Pixeles de color blanco matriz.drawPixel(15, 3, matriz.Color(255, 255 ,255)); matriz.drawPixel(15, 4, matriz.Color(255, 255 ,255)); matriz.drawPixel(16, 3, matriz.Color(255, 255 ,255)); matriz.drawPixel(16, 4, matriz.Color(255, 255 ,255)); delay(500); matriz.show(); // Cuadrado relleno de color verde matriz.fillRect(1,1,13,6, matriz.Color(0,255,0)); delay(1000); matriz.show(); // Contorno de cuadrado en color verde matriz.drawRect(18,1,13,6, matriz.Color(0,255,0)); delay(1000); matriz.show(); // Contorno cuadrado de color amarillo matriz.drawRect(0,0,32,8, matriz.Color(255,255,0)); delay(1000); matriz.show(); // Contorno cuadrado de color azul matriz.drawRect(14,1,4,6, matriz.Color(0,0,255)); delay(1000); matriz.show(); // Cuadrado relleno de color rojo matriz.fillRect(19,2,11,4, matriz.Color(255,0,0)); delay(1000); matriz.show(); } La secuencia de im\u00e1genes siguiente es el resultado de cargar el programa dibujo_rectangulos en un Keyestudio UNO. Ejemplo de dibujo de pixeles y rect\u00e1ngulos L\u00edneas y circulos \u00b6 Para dibujar l\u00edneas damos las coordinadas del punto inicial y del punto final seguidas del c\u00f3digo de color, o sea haremos: // dibujar una linea matriz.drawLine(xi, yi, xf, yf, matrix.Color(R, G, B)); Para dibujar circulos rellenos damos las coordenadas del centro y el radio, o sea hacemos lo siguiente: // dibujar un c\u00edrculo relleno matriz.fillCircle(x0, y0, r, matrix.Color(R, G, B)); Para dibujar un c\u00edrculo la forma de proceder es: // dibujar un circulo matriz.drawCircle(x0, y0, r, matrix.Color(R, G, B)); En el ejemplo dibujo_lineas_circulos vemos algunos casos de estos dos dibujos y a continuaci\u00f3n tenemos el c\u00f3digo del programa completo. // Invocamos librer\u00edas #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> // Definimos patilla de salida de datos #define PIN 3 //Creamos el objeto matriz Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN, NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); void setup() { matriz.begin(); // Iniciamos el objeto matriz.setBrightness(15); // Establece el brillo en un 15% } int x = matriz.width(); // Calculo de la anchura de la matriz void loop(){ matriz.fillScreen(0); //Apaga todos los LEDs delay(1000); matriz.show(); matriz.setCursor(x, 0); // Coloca el cursor en la posici\u00f3n 31,0 en este caso concreto // Hacer una X roja que ocupa la mitad de la matriz matriz.drawLine(0, 0, 16, 7, matriz.Color(255, 0 ,0)); matriz.drawLine(16, 0, 0, 7, matriz.Color(255, 0 ,0)); // Hacer una X azul que ocupa la otra mitad de la matriz matriz.drawLine(17, 0, 31, 7, matriz.Color(0, 0 ,255)); matriz.drawLine(31, 0, 17, 7, matriz.Color(0, 0 ,255)); // Dibujar circulos matriz.fillCircle(2,4,1, matriz.Color(255,0,255)); matriz.fillCircle(30,3,1, matriz.Color(255,0,255)); matriz.drawCircle(17,4,2, matriz.Color(0,255,255)); matriz.show(); } En la figura siguiente vemos el resultado. Ejemplo de dibujo de l\u00edneas y c\u00edrculos Textos \u00b6 Para mostrar textos lo primero que debemos hacer es establecer la ubicaci\u00f3n del cursor con setCursor . Debemos tener en cuenta que los caracteres de texto tienen una altura de 8 p\u00edxeles de forma predeterminada y la posici\u00f3n del primer pixel del primer caracter. Con setTextSize podemos establecer el tama\u00f1o en 1 (8 p\u00edxeles de alto) o 2 (16 p\u00edxeles de alto) y finalmente debemos establecer el color del texto con setTextColor . Una vez hecho todo esto, podemos usar print('1') para imprimir el car\u00e1cter \"1\". El ejemplo Textos nos va a ir mostrando a intervalos de dos segundos las cadenas \"-RGB-\", \"32x8\" y \"Pixel\" en diferentes colores y el c\u00f3digo es el siguiente: // Invocamos librer\u00edas #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> // Definimos patilla de salida de datos #define PIN 3 //Creamos el objeto matriz Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN, NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); void setup() { matriz.begin(); // Iniciamos el objeto matriz.setBrightness(15); // Establece el brillo en un 15% } void loop(){ matriz.fillScreen(0); //Apaga todos los LEDs matriz.setTextSize(1); // 1 == 8 pixeles matriz.setCursor(1, 0); // Coloca el cursor en la posici\u00f3n 4,0 en este caso concreto matriz.setTextColor(matriz.Color(255,0,0)); matriz.print('-'); matriz.setTextColor(matriz.Color(255,127,0)); matriz.print('R'); matriz.setTextColor(matriz.Color(255,255,0)); matriz.print('G'); matriz.setTextColor(matriz.Color(127,255,0)); matriz.print('B'); matriz.setTextColor(matriz.Color(0,127,0)); matriz.print('-'); matriz.show(); delay(2000); matriz.fillScreen(0); //Apaga todos los LEDs matriz.setCursor(4, 0); // Coloca el cursor en la posici\u00f3n 4,0 en este caso concreto matriz.setTextColor(matriz.Color(0,255,255)); matriz.print('3'); matriz.setTextColor(matriz.Color(0,127,255)); matriz.print('2'); matriz.setTextColor(matriz.Color(127,0,255)); matriz.print('x'); matriz.setTextColor(matriz.Color(127,0,127)); matriz.print('8'); matriz.show(); delay(2000); matriz.fillScreen(0); //Apaga todos los LEDs matriz.setCursor(2, 0); // Coloca el cursor en la posici\u00f3n 4,0 en este caso concreto matriz.setTextColor(matriz.Color(255,0,255)); matriz.print('P'); matriz.print('i'); matriz.print('x'); matriz.print('e'); matriz.print('l'); matriz.show(); delay(2000); } Uso de memoria RAM \u00b6 La librer\u00eda NeoMatrix no consume m\u00e1s memoria que NeoPixel, ya que requiere 3 bytes de RAM por cada p\u00edxel. Ahora bien, la cantidad de p\u00edxeles en una pantalla bidimensional aumenta exponencialmente, como vemos haciendo unos c\u00e1lculos sencillos: Pantalla \\space de \\space 8x8 \\space = \\space 64 \\implies Memoria \\space = \\space 192 \\space bytes Pantalla \\space de \\space 8x8 \\space = \\space 64 \\implies Memoria \\space = \\space 192 \\space bytes Pantalla \\space de \\space 16x16 \\space = \\space 256 \\implies Memoria \\space = \\space 768 \\space bytes Pantalla \\space de \\space 16x16 \\space = \\space 256 \\implies Memoria \\space = \\space 768 \\space bytes 64 \\times 4 \\space = \\space 256 \\space y \\space 192 \\times 4 \\space = 768 64 \\times 4 \\space = \\space 256 \\space y \\space 192 \\times 4 \\space = 768 Es decir, que una pantalla de 16x16 requiere cuatro veces mas memoria que una pantalla de 8x8, o aproximadamente de 768 bytes de RAM. Teniendo en cuenta que una placa UNO o nano tienen disponible una memoria SRAM de 2 kbytes, podemos decir que una matriz de 16x16 consume casi la mitad de esa memoria. Puede ser complicado o imposible combinar pantallas grandes con bibliotecas que consumen mucha memoria. Correcci\u00f3n gamma \u00b6 La respuesta a la luz del ojo humano tiene forma logar\u00edtmica, lo que significa que cuando vemos una escala de grises, nos parece que el brillo aumenta de forma continua, pero la cantidad real de luz aumenta de forma exponencial, y ese exponente es lo que se conoce como Gamma . Como referencia, un valor de gamma habitual es 2,4, es decir que cada valor tiene 2,4 veces la cantidad de luz del valor anterior. Este comportamiento exponencial ocurr\u00eda en aparatos con tubos de vacio. Actualmente se utilizan; en monitores LCD, plasma u OLED, sensores de estado s\u00f3lido, y estos tienen una respuesta lineal o muy aproximada. Esto nos da pie a pensar que Gamma es algo que est\u00e1 obsoleto, pero nada mas lejos de la realidad, ya que est\u00e1 totalmente de actualidad debido a que es un m\u00e9todo de compresi\u00f3n muy eficaz, con el que nos aseguramos que s\u00f3lo se asignan, se guardan y se transmiten valores (y diferencias de valores) que son visibles por el ojo humano, y que no se usan bits para codificar incrementos de brillo que el ojo no va a percibir. Podemos encontrar mucha mas informaci\u00f3n sobre \u00bfQu\u00e9 es gamma? en el enlace. La librer\u00eda GFX se dise\u00f1\u00f3 originalmente para pantallas LCD (con una fidelidad de color limitada), manejando los colores como valores de 16 bits (en lugar de los 24 bits completos de los que son capaces los NeoPixels). Esta no es la gran p\u00e9rdida que podr\u00eda parecer. Una peculiaridad de la visi\u00f3n humana hace que los colores brillantes sean menos perceptibles que los tenues. La biblioteca NeoMatrix utiliza la correcci\u00f3n gamma para seleccionar niveles de brillo que son visualmente (aunque no num\u00e9ricamente) equidistantes. Hay 32 niveles para rojo y azul, 64 niveles para verde. La funci\u00f3n Color() realiza la conversi\u00f3n necesaria; no necesitas hacer ning\u00fan c\u00e1lculo. Acepta valores de rojo, verde y azul de 8 bits y devuelve un color de 16 bits con correcci\u00f3n gamma que luego se puede pasar a otras funciones de dibujo.","title":"Matriz WS2812 8x32"},{"location":"temas/matriz8x32/#matriz-o-panel-de-8x32","text":"","title":"Matriz o panel de 8x32"},{"location":"temas/matriz8x32/#descripcion","text":"En realidad se trata de tiras de 256 LEDs dispuestos en forma de panel o matriz que tienen el aspecto de la figura siguiente: Aspecto de una matriz de 8x32 Podemos observar que este tipo de paneles son, hasta cierto punto, flexibles y que permiten utilizar el concepto de apilado o encadenado conectando la salida de uno a la entrada del otro. En principio la \u00fanica limitaci\u00f3n de conexionado va a estar en la capacidad de entregar la corriente que demande la configuraci\u00f3n de paneles. Referente al tema de la alimentaci\u00f3n hemos de tener presente que cada uno de los LEDs puede consumir hasta 60 mA (20 mA cada color) si combinamos los colores a m\u00e1ximo brillo para obtener un color blanco intenso, por lo que el consumo m\u00e1ximo puede ser de: I\\_max = 8 \\cdot32 \\cdot 60 = 15.360\\space mA I\\_max = 8 \\cdot32 \\cdot 60 = 15.360\\space mA Es decir, que en las condiciones indicadas un panel puede llegar a consumir por encima de 15A, lo que nos indica claramente que tampoco est\u00e1n dise\u00f1ados para trabajar de esta forma. En condiciones de brillo por debajo de 100 y los LEDs cambiando su estado (por ejemplo en un letrero que se desplaza) un panel se puede alimentar desde el conector de entrada que tiene 3 pines: DIN, 5V y GND. Los LEDs WS2812 que se utilizan son de 4 pines que se distribuyen en cada LED como vemos en la figura siguiente: Pines LED WS2812 El panel o matriz que vamos a utilizar conecta los LEDs como vemos en la figura siguiente: Panel con conexi\u00f3n en linea La parte posterior de este panel tiene el aspecto de la figura siguiente: Parte posterior del panel Aunque debemos tener presente que los LEDs se pueden conectar de cualquiera de las formas que vemos en la figura siguiente: Conexiones en zig zag y en linea","title":"Descripci\u00f3n"},{"location":"temas/matriz8x32/#programacion-con-arduinoblocks","text":"","title":"Programaci\u00f3n con ArduinoBlocks"},{"location":"temas/matriz8x32/#bloques","text":"En la figura siguiente vemos el men\u00fa bloques disponible en 'Visualizaci\u00f3n' en su entrada 'NeoPixel'. Bloques LEDs RGB direccionables Ya hemos indicado que la disposici\u00f3n en forma de matriz no implica que el conexionado de los LEDs est\u00e9 realizado de esa forma, sino que est\u00e1n conectados como si de una tira se tratase y por ello los bloques tipo matriz no van a servirnos de mucha ayuda en la programaci\u00f3n de estos elementos, y por eso se han puesto difuminados. Para demostrar esto se anima al lector a analizar el posible resultado de un simple programa como el de la figura siguiente: Ejemplo para demostrar que no se programa como matriz Si cargamos el programa Ej_no_matriz.abp en nuestra placa y lo hacemos funcionar con el panel conectado podremos observar como su comportamiento nada tiene que ver con el esperado.","title":"Bloques"},{"location":"temas/matriz8x32/#ejemplos-de-uso","text":"Vamos a ver una serie de ejemplos de uso del panel tratado como tira de LEDs direccionables para ver que as\u00ed funciona perfectamente. A1. Encender y apagar todos los LEDs . En esta primera actividad vamos a establecer un nivel de brillo lo suficientemente bajo (15) como para que cuando se enciendan todos los LEDs nuestro USB no se desconecte por exceso de consumo. Si queremos trabajar con brillos mayores basta con alimentar el panel a trav\u00e9s de los cables destinados a ello con una fuente de alimentaci\u00f3n adecuada, pero recordemos el consumo m\u00e1ximo que pueden llegar a tener si los ponemos todos a m\u00e1ximo brillo y en blanco, que supera los 15A. Por otro lado en el bucle de encendido hemos dado un peque\u00f1o retardo que demuestra claramente como est\u00e1n conectados los LEDs. En el enlace tenemos el programa A1. Encender y apagar todos los LEDs siguiente: A1. Encender y apagar todos los LEDs A2. Encender todos desplazando el LED encendido . Se trata del mismo bucle que en la actividad anterior pero en esta ocasi\u00f3n borramos los datos en cada iteraci\u00f3n haciendo as\u00ed que solamente se encienda un LED. En el enlace tenemos el programa A2. Encender todos desplazando el LED encendido siguiente: A2. Encender todos desplazando el LED encendido A3. Encender pares e impares con color aleatorio . Con un bucle encendemos los LEDs de color par despu\u00e9s de llamar a la funci\u00f3n que establece de forma aleatoria los valores RGB, con otro hacemos lo mismo pero con los impares y finalmente con otro bucle los apagamos todos durante un tiempo. En el enlace tenemos el programa A3. Encender pares e impares con color aleatorio siguiente: A3. Encender pares e impares con color aleatorio De esta forma podemos seguir haciendo cosas con el panel pero la verdad es que salvo la disposici\u00f3n de los LEDs no se ven muchas mas posibilidades","title":"Ejemplos de uso"},{"location":"temas/matriz8x32/#trabajo-con-la-herramienta-neopixel-matrix-data","text":"Accedemos a ella a trav\u00e9s el men\u00fa herramientas, tal y como vemos en la animaci\u00f3n de la figura siguiente. Observamos como establecer el tipo de matriz seg\u00fan est\u00e9n conexionados los LEDs en l\u00ednea o zig zag y simplemente se han pintado algunos pixeles de diferentes colores a modo de ejemplo. Herramienta Neopixel - Matrix data Ejemplo de uso de la herramienta Neopixel - Matrix data Mostrar ese dise\u00f1o en la matriz es tan sencillo como hacer un programa como el de la figura siguiente. Ejemplo de uso de la herramienta Neopixel - Matrix data Hemos copiado los datos generados en el bloque 'Establecer datos'. Es posible realizar dise\u00f1os mas complejos con esta herramienta, como por ejemplo escribir textos, pero nos vamos a encontrar que es un trabajo bastante complejo, lento y tedioso al que adem\u00e1s se a\u00f1ade una dificultad, y es que el dise\u00f1o en pantalla est\u00e1 en posici\u00f3n espejo (como si se reflejase en uno) respecto a la posici\u00f3n real de los diodos del panel del que dispongo. Un ejemplo, con alg\u00fan peque\u00f1o error que no se ha corregido a prop\u00f3sito, como el que vemos en el v\u00eddeo siguiente ha costado algo mas de una hora llevarlo a cabo.Adafruit_NeoMatrix Tambi\u00e9n existe una herramienta de generaci\u00f3n de los datos a partir de una imagen, pero esta debe tener una resoluci\u00f3n similar a la del panel para que obtengamos algo viable. En la imagen siguiente vemos el resultado obtenido a partir de la imagen original de la izquierda y vemos que se parecen en poco o nada. Ejemplo de uso de la herramienta Neopixel - Matrix data Aunque podemos crear efectos y alguna cosa mas parece evidente que hoy por hoy (enero de 2023) no se trabaja con eficiencia en ArduinoBlocks con este tipo de elementos. Vamos a ver a continuaci\u00f3n como hacerlo de una mejor manera utilizando el IDE de Arduino y las librer\u00edas necesarias para su funcionamiento.","title":"Trabajo con la herramienta Neopixel - Matrix data"},{"location":"temas/matriz8x32/#librerias","text":"Para un correcto funcionamiento vamos a necesitar las siguientes bibliotecas: Adafruit_GFX Adafruit_NeoMatrix Adafruit_NeoPixel Si no las tenemos instaladas procedemos a su descarga de los enlaces anteriores y a su instalaci\u00f3n siguiendo el proceso descrito en el punto \"Gestor de librer\u00edas\" del apartado IDE 2 . Si estamos utilizando un IDE anterior a la versi\u00f3n (1.8.10) tambi\u00e9n debemos tener instalada la librer\u00eda BusIO . Por lo tanto, todos nuestros programas o sketches deben incluir como cabecera las tres l\u00edneas de c\u00f3digo siguientes: #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h>","title":"Librer\u00edas"},{"location":"temas/matriz8x32/#libreria-gfx","text":"Se trata de una librer\u00eda que nos proporciona un conjunto de funciones gr\u00e1ficas que incluyen l\u00edneas, c\u00edrculos y texto y que se utilizan de forma habitual en pantallas LCD y OLED. Utiliza un sistema de coordenadas y unidades que permiten referenciar cada pixel a partir de un punto o coordenada de origen (0,0) que se sit\u00faa en la esquina superior izquierda, de manera que X es positivo hacia la derecha e Y hac\u00eda abajo. Es posible aplicar hasta cuatro rotaciones para indicar que esquina de la pantalla representa la parte superior izquierda. Las coordenadas siempre se expresan en pixeles, lo que implica que no existe una escala de medida real como el mil\u00edmetro, y por lo tanto el tama\u00f1o de un determinado gr\u00e1fico es funci\u00f3n del tama\u00f1o del punto o de la densidad de pixeles de la pantalla en la que se muestra. El n\u00famero de puntos de una pantalla se suele indicar en su datasheet o bien calcular midiendo el ancho de la misma y dividiendo por la cantidad de pixeles. Aunque cada pantalla concreta va a disponer de sus propias funciones constructoras e inicializadoras existen una serie de prototipos que son: Dibujar pixles (puntos) . Lo m\u00e1s b\u00e1sico que podemos dibujar en una pantalla es un punto a partir de especificar su coordenada X,Y y su color: void drawPixel (uint16_t x, uint16_t y, uint16_t color); Dibujar l\u00edneas . Debemos especificar el punto inicial, el punto final y el color: void drawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t color); Si se trata de l\u00edneas horizontales o verticales tenemos las dos funciones siguientes: void drawFastVLine(uint16_t x0, uint16_t y0, uint16_t length, uint16_t color); // Vertical void drawFastHLine(uint8_t x0, uint8_t y0, uint8_t length, uint16_t color); // Horizontal Rect\u00e1ngulos . Se pueden crear cuadrados o rect\u00e1ngulos, que se pueden rellenar o no, utilizando los siguientes procedimientos: void drawRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color); void fillRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color); La anchura se especifica en las coordenadas X y la altura se especifica en las coordenadas Y. C\u00edrculos . Tambi\u00e9n los c\u00edrculos se pueden rellenar y dibujar indicando en este caso el centro el primer par X,Y y el radio el segundo par X,Y. Los procedimientos son: void drawCircle(uint16_t x0, uint16_t y0, uint16_t r, uint16_t color); void fillCircle(uint16_t x0, uint16_t y0, uint16_t r, uint16_t color); Rect\u00e1ngulos redondeados . Tambi\u00e9n pueden dibujarse y rellenarse. En primer lugar se indican el ancho y el alto como en rect\u00e1ngulos normales, luego se indica el radio de las esquinas (en pixeles) y finalmente se indica el color. void drawRoundRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t radius, uint16_t color); void fillRoundRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t radius, uint16_t color); Tri\u00e1ngulos . De nuevo est\u00e1 disponible la opci\u00f3n de relleno. En esta ocasi\u00f3n se requieren un par de coordenadas para cada v\u00e9rtice seguidas de un color: void drawTriangle(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color); void fillTriangle(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color); Caracteres y texto . Si queremos a\u00f1adir un solo car\u00e1cter indicamos la coordenada donde lo posicionamos, el color y el color de fondo. Opcionalmente se puede a\u00f1adir otro par\u00e1metro para escalar la fuente en un determinado factor, por ejemplo size=2 pondr\u00e1 la fuente en un tama\u00f1o de 10x16 pixeles. void drawChar(uint16_t x, uint16_t y, char c, uint16_t color, uint16_t bg, uint8_t size); Para escribir una cadena lo que se hace es configurar los par\u00e1metros en procedimientos separados y finalmente se usa la funci\u00f3n 'print()' o bien 'println' , como vemos a continuaci\u00f3n: void setCursor(int16_t x0, int16_t y0); void setTextColor(uint16_t color); void setTextColor(uint16_t color, uint16_t backgroundcolor); void setTextSize(uint8_t size); void setTextWrap(boolean w); println(\"Hola\"); void setTextSize(2); println(\"4321.98); void setTextSize(3); println(0xABCDEFG, HEX);void fillScreen(uint16_t color); Comienza con setCursor(x, y) , que sit\u00faa la esquina superior izquierda del texto, por defecto es (0,0), luego establecemos el color del texto con setTextColor(color), que por defecto es blanco. El texto normalmente se dibuja en color \"claro\" pero si queremos se puede especificar un color de fondo como segundo par\u00e1metro opcional para setTextColor(). Finalmente, setTextSize(size) multiplicar\u00e1 la escala del texto por un factor entero dado. De forma predeterminada, las l\u00edneas largas de texto est\u00e1n configuradas para \"ajustarse\" autom\u00e1ticamente a la columna m\u00e1s a la izquierda. Para anular este comportamiento se utiliza 'setTextWrap(false)' . El comportamiento de ajuste normal se restaura con 'setTextWrap(true)' . Mapas de bits . Es posible dibujar mapas de bits monocrom\u00e1ticos. void drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h, uint16_t color); Esto crea un bloque contiguo de bits en la pantalla, donde cada bit '1' ilumina el p\u00edxel correspondiente en 'color', mientras que se omite cada bit '0'. las coordenadas x,y fijan la esquina superior izquierda donde se dibuja el mapa de bits, w, h son el ancho y el alto en p\u00edxeles. Los datos del mapa de bit deben estar en la memoria de programa. Limpiar o rellenar la pantalla . Se trata de una funci\u00f3n que configura toda la pantalla en un color dado. Si el color es negro equivale a borrarla ya que todos los LEDs se ponen en negro, es decir se apagan. void fillScreen(uint16_t color);","title":"Librer\u00eda GFX"},{"location":"temas/matriz8x32/#libreria-neopixel","text":"Esta es la librer\u00eda que hemos venido utilizando en ArduinoBlocks para trabajar con el panel como tira de LEDs direccionables. Para trabajar con tiras de LEDs son necesarias las siguientes tres l\u00edneas de c\u00f3digo: #define LED_PIN 6 // Pin de datos #define LED_COUNT 60 // Numero de LEDs de la tira // Declaraci\u00f3n del objeto NeoPixel strip: Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800); Los par\u00e1metros o argumentos del objeto para una funci\u00f3n como Adafruit_NeoPixel neo_pixel = Adafruit_NeoPixel(256,2,NEO_GRB+NEO_KHZ800); son los siguientes: 1: N\u00famero de p\u00edxeles en la tira. LED_COUNT = 256 2: N\u00famero de pin de Arduino. LED_PIN = 2 3: Indicadores de tipo de p\u00edxel, la suma ser\u00e1 alguna de estas combinaciones: NEO_KHZ800 Flujo de bits de 800 KHz (la mayor\u00eda de los productos se hacen con LEDs WS2812) NEO_KHZ400 400 KHz (p\u00edxeles FLORA cl\u00e1sicos 'v1' (no v2), controladores WS2811) Los p\u00edxeles NEO_GRB est\u00e1n cableados para flujo de bits GRB (la mayor\u00eda de los productos) Los p\u00edxeles NEO_RGB est\u00e1n cableados para flujo de bits RGB (p\u00edxeles FLORA v1 , no v2) Los p\u00edxeles NEO_RGBW est\u00e1n cableados para el flujo de bits RGBW (productos NeoPixel RGBW) Existen diferentes funciones para manejo de una tira de LEDs que no vamos a definir aqu\u00ed pues ya est\u00e1n definidas en ArduinoBlocks.","title":"Librer\u00eda NeoPixel"},{"location":"temas/matriz8x32/#libreria-neomatrix","text":"Se trata de una biblioteca o librer\u00eda de Adafruit , basada en NeoPixel, que permite crear pantallas gr\u00e1ficas bidimensionales utilizando los paneles que estamos viendo. Esto nos va a permitir dibujar f\u00e1cilmente formas, texto y animaciones sin tener que calcular la posici\u00f3n XY de cada p\u00edxel. NeoMatrix de Adafruit utiliza el mismo sistema de coordenadas, funciones de color y comandos gr\u00e1ficos que la biblioteca GFX que hemos visto. Vamos a centrar nuestra atenci\u00f3n en c\u00f3mo declarar una pantalla bidimensional hecha a partir de LEDs direccionables o NeoPixels. La librer\u00eda o biblioteca es capaz de manejar tanto matrices individuales (todos los LEDs en una sola cuadr\u00edcula uniforme) como matrices en mosaico (m\u00faltiples cuadr\u00edculas combinadas en una pantalla m\u00e1s grande): Matrices simples o agrupadas El siguiente paso es invocar a la directiva del preprocesador #ifndef para comprobar si la macro PSTR est\u00e1 definida. Esta macro (definida en pgmspace.h ) sirve para declarar cadenas flash en un bloque de c\u00f3digo para escribir y leer en la memoria de programa PROGMEM. Esto es conveniente hacerlo porque la librer\u00eda utiliza la correcci\u00f3n gamma del color para minimizar el consumo. El c\u00f3digo ahora estar\u00eda as\u00ed: #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> #ifndef PSTR #define PSTR #endif Con esto estamos en condiciones de crear la declaraci\u00f3n de nuestra matriz, lo que se hace mediante la siguiente l\u00ednea de c\u00f3digo: Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(WIDTH, HEIGTH, Hor, Ver, PIN, matrix_layout_flags); Con esto invocamos al constructor para que nos cree el elemento 'matriz' con los par\u00e1metros definidos entre par\u00e9ntesis y separados por comas y que vamos a explicar a continuaci\u00f3n: Par\u00e1metro 1, WIDTH : Define el ancho de la matriz individual o de cada matriz en una agrupaci\u00f3n (no del total de la pantalla) Par\u00e1metro 2, HEIGTH : Define la altura de la matriz individual o de cada matriz en una agrupaci\u00f3n Par\u00e1metro 3, Hor : N\u00famero de matrices conectadas horizontalmente Par\u00e1metro 4, Ver : N\u00famero de matrices conectadas verticalmente Par\u00e1metro 5, PIN : N\u00famero de pin que usaremos como salida de datos de nuestra placa y que ir\u00e1 conectado a la entrada DIN de la matriz. Par\u00e1metro 6, matrix_layout_flags : Aqu\u00ed es donde tenemos que definir las banderas o flags de dise\u00f1o de nuestra matriz o pantalla (agrupaci\u00f3n de matrices) y se hace sumando todos los que necesitemos de los siguientes: Posici\u00f3n del primer LED de la primera matriz: NEO_MATRIX_TOP, NEO_MATRIX_BOTTOM, NEO_MATRIX_LEFT, NEO_MATRIX_RIGHT Por ejemplo: NEO_MATRIX_TOP + NEO_MATRIX_LEFT para esquina superior izquierda Disposici\u00f3n de los LEDs en cada matriz: NEO_MATRIX_ROWS, NEO_MATRIX_COLUMNS: Elegimos uno u otro Forma de conexionado de filas/columnas: NEO_MATRIX_PROGRESSIVE, NEO_MATRIX_ZIGZAG: Elegimos uno Posici\u00f3n de la primera matriz en un mosaico: NEO_TILE_TOP, NEO_TILE_BOTTOM, NEO_TILE_LEFT, NEO_TILE_RIGHT Por ejemplo: NEO_TILE_TOP + NEO_TILE_LEFT para esquina superior izquierda Disposici\u00f3n de las matrices en la pantalla: NEO_TILE_ROWS, NEO_TILE_COLUMNS: Elegimos uno u otro Tipo de matriz: NEO_RGB, para pixeles V1 con flujo de datos (bitstream) RGB NEO_GRB, para pixeles V2 con flujo de datos (bitstream) GRB NEO_KHZ400, para bitstream de 400 KHz (por ejemplo pixeles FLORA V1) NEO_KHZ800, para bitstream de 800 KHz (por ejemplo tiras de alta densidad de LEDs) Nuestro c\u00f3digo podr\u00eda continuar, por ejemplo, de la forma siguiente: #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> #ifndef PSTR #define PSTR #endif #define PIN 3 Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(32, 8, 2, 1, PIN, NEO_TILE_TOP + NEO_TILE_LEFT + NEO_TILE_ROWS + NEO_TILE_PROGRESSIVE + NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); El constructor de la matriz nos facilita la siguiente informaci\u00f3n de ayuda: Ayuda del constructor Observamos como los par\u00e1metros 1 al 5 deben ser n\u00fameros enteros positivos de 8 bits, es decir, hasta 255. Un ejemplo de definici\u00f3n de una matriz de 32x8 en un solo panel podr\u00eda ser como sigue: Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(32, 8, PIN, NEO_MATRIX_TOP + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_PROGRESSIVE, NEO_GRB + NEO_KHZ800); El resto de tareas las vamos a ver utilizando un ejemplo comentado en el que usamos una pantalla de 64x8 pixeles formada a partir de 2 matrices de 32x8 pixeles en la que vamos a hacer que un texto se desplace cmabiando en cada iteraci\u00f3n el color de las letras entre 8 posibles combinaciones. El ejemplo NavidadConCiencia que puedes descargar del enlace tiene el siguiente c\u00f3digo: // Invocamos librer\u00edas #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> // Definimos patilla de salida de datos #define PIN 3 //Creamos el objeto matriz Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, 2, 1, PIN, NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); // Definimos vectores de colores const uint16_t colors[] = { matriz.Color(255, 0, 0), matriz.Color(0, 255, 0), matriz.Color(255, 255, 0), matriz.Color(0, 0, 255), matriz.Color(255, 0, 255), matriz.Color(0, 255, 255), matriz.Color(255, 128, 0), matriz.Color(255, 255, 255)}; void setup() { matriz.begin(); // Iniciamos el objeto matriz.setTextWrap(false); // Relativo a si se recorta o no el texto si es mayor que la matriz matriz.setBrightness(15); // Establece el brillo en un 15% matriz.setTextColor(colors[0]); // Se establece el primer color como inicial } int x = matriz.width(); // Calculo de la anchura de la matriz int pases = 0; // Pasadas para el cambio de color void loop(){ matriz.fillScreen(0); //Apaga todos los LEDs matriz.setCursor(x, 0); // Coloca el cursor en la posici\u00f3n 64,0 en este caso concreto char cadena[] = \"Parque de las Ciencias - openLAB - Club Robotica Granada\"; // Cadena a mostrar int longitud_cadena = strlen(cadena); // N\u00famero de caracteres de la cadena int longitud_pixels = longitud_cadena * 6; // Cada caracter ocupa 5 pixeles mas un espacio, en total 6 pixeles matriz.print((cadena)); // Mostrar la cadena if( --x < -longitud_pixels ) // Decremento de la posici\u00f3n X en funci\u00f3n de la variable { x = matriz.width(); // Reiniciamos la variable if(++pases >= 8) pases = 0; // Comprobamos si hemos llegado al \u00faltimo vector de color matriz.setTextColor(colors[pases]); // Establce el color seg\u00fan el \u00edndice del vector } matriz.show(); // Muestra la pantalla delay(100); } La declaraci\u00f3n del objeto matriz tambi\u00e9n se puede hacer de la forma siguiente: Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(64, 8, PIN, NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); En el video siguiente podemos ver el resultado de este programa.","title":"Librer\u00eda NeoMatrix"},{"location":"temas/matriz8x32/#dibujos-basicos","text":"Veremos ejemplos simples de uso de la librer\u00eda para crear dibujos sencillos como dibujar un pixel, un cuadrado relleno o no, l\u00edneas, c\u0155culos rellenos o no y como poner un texto fijo.","title":"Dibujos b\u00e1sicos"},{"location":"temas/matriz8x32/#pixeles-y-cuadrados","text":"Lo m\u00e1s sencillo que podemos dibujar es un pixel de un color determinado y para ello basta con invocar el siguiente comando: // dibujar un pixel de color blanco matriz.drawPixel(x, y, matrix.Color(R, G, B)); Para dibujar un contorno rectangular relleno haremos lo siguiente: // dibujar un rectangulo s\u00f3lido matriz.fillRect(xi, yi, xrf, yrf, matrix.Color(R, G, B)); Damos las coordenadas del v\u00e9rtice inicial y las del opuesto en su diagonal, siendo estas \u00faltimas relativas pues se cuentan a partir de las iniciales. Para dibujar el contorno de un rectangulo haremos lo siguiente: // dibujar un rectangulo matriz.drawRect(xi, yi, xrf, yrf, matrix.Color(R, G, B)); En el ejemplo siguiente se dibujan los cuatro pixeles centrales en color blanco, un rect\u00e1ngulo relleno, un rect\u00e1ngulo, otro rect\u00e1ngulo perimetral, un rect\u00e1ngulo que rodea a los pixeles y finalmente otro rect\u00e1ngulo s\u00f3lido de color rojo en el interior del rect\u00e1ngulo verde. // Invocamos librer\u00edas #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> // Definimos patilla de salida de datos #define PIN 3 //Creamos el objeto matriz Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN, NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); void setup() { matriz.begin(); // Iniciamos el objeto### <FONT COLOR=#AA0000>L\u00edneas y circulos</font> matriz.setBrightness(15); // Establece el brillo en un 15% } int x = matriz.width(); // Calculo de la anchura de la matriz void loop(){ matriz.fillScreen(0); //Apaga todos los LEDs delay(1000); matriz.show(); matriz.setCursor(x, 0); // Coloca el cursor en la posici\u00f3n 31,0 en este caso concreto // Pixeles de color blanco matriz.drawPixel(15, 3, matriz.Color(255, 255 ,255)); matriz.drawPixel(15, 4, matriz.Color(255, 255 ,255)); matriz.drawPixel(16, 3, matriz.Color(255, 255 ,255)); matriz.drawPixel(16, 4, matriz.Color(255, 255 ,255)); delay(500); matriz.show(); // Cuadrado relleno de color verde matriz.fillRect(1,1,13,6, matriz.Color(0,255,0)); delay(1000); matriz.show(); // Contorno de cuadrado en color verde matriz.drawRect(18,1,13,6, matriz.Color(0,255,0)); delay(1000); matriz.show(); // Contorno cuadrado de color amarillo matriz.drawRect(0,0,32,8, matriz.Color(255,255,0)); delay(1000); matriz.show(); // Contorno cuadrado de color azul matriz.drawRect(14,1,4,6, matriz.Color(0,0,255)); delay(1000); matriz.show(); // Cuadrado relleno de color rojo matriz.fillRect(19,2,11,4, matriz.Color(255,0,0)); delay(1000); matriz.show(); } La secuencia de im\u00e1genes siguiente es el resultado de cargar el programa dibujo_rectangulos en un Keyestudio UNO. Ejemplo de dibujo de pixeles y rect\u00e1ngulos","title":"Pixeles y cuadrados"},{"location":"temas/matriz8x32/#lineas-y-circulos","text":"Para dibujar l\u00edneas damos las coordinadas del punto inicial y del punto final seguidas del c\u00f3digo de color, o sea haremos: // dibujar una linea matriz.drawLine(xi, yi, xf, yf, matrix.Color(R, G, B)); Para dibujar circulos rellenos damos las coordenadas del centro y el radio, o sea hacemos lo siguiente: // dibujar un c\u00edrculo relleno matriz.fillCircle(x0, y0, r, matrix.Color(R, G, B)); Para dibujar un c\u00edrculo la forma de proceder es: // dibujar un circulo matriz.drawCircle(x0, y0, r, matrix.Color(R, G, B)); En el ejemplo dibujo_lineas_circulos vemos algunos casos de estos dos dibujos y a continuaci\u00f3n tenemos el c\u00f3digo del programa completo. // Invocamos librer\u00edas #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> // Definimos patilla de salida de datos #define PIN 3 //Creamos el objeto matriz Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN, NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); void setup() { matriz.begin(); // Iniciamos el objeto matriz.setBrightness(15); // Establece el brillo en un 15% } int x = matriz.width(); // Calculo de la anchura de la matriz void loop(){ matriz.fillScreen(0); //Apaga todos los LEDs delay(1000); matriz.show(); matriz.setCursor(x, 0); // Coloca el cursor en la posici\u00f3n 31,0 en este caso concreto // Hacer una X roja que ocupa la mitad de la matriz matriz.drawLine(0, 0, 16, 7, matriz.Color(255, 0 ,0)); matriz.drawLine(16, 0, 0, 7, matriz.Color(255, 0 ,0)); // Hacer una X azul que ocupa la otra mitad de la matriz matriz.drawLine(17, 0, 31, 7, matriz.Color(0, 0 ,255)); matriz.drawLine(31, 0, 17, 7, matriz.Color(0, 0 ,255)); // Dibujar circulos matriz.fillCircle(2,4,1, matriz.Color(255,0,255)); matriz.fillCircle(30,3,1, matriz.Color(255,0,255)); matriz.drawCircle(17,4,2, matriz.Color(0,255,255)); matriz.show(); } En la figura siguiente vemos el resultado. Ejemplo de dibujo de l\u00edneas y c\u00edrculos","title":"L\u00edneas y circulos"},{"location":"temas/matriz8x32/#textos","text":"Para mostrar textos lo primero que debemos hacer es establecer la ubicaci\u00f3n del cursor con setCursor . Debemos tener en cuenta que los caracteres de texto tienen una altura de 8 p\u00edxeles de forma predeterminada y la posici\u00f3n del primer pixel del primer caracter. Con setTextSize podemos establecer el tama\u00f1o en 1 (8 p\u00edxeles de alto) o 2 (16 p\u00edxeles de alto) y finalmente debemos establecer el color del texto con setTextColor . Una vez hecho todo esto, podemos usar print('1') para imprimir el car\u00e1cter \"1\". El ejemplo Textos nos va a ir mostrando a intervalos de dos segundos las cadenas \"-RGB-\", \"32x8\" y \"Pixel\" en diferentes colores y el c\u00f3digo es el siguiente: // Invocamos librer\u00edas #include <Adafruit_GFX.h> #include <Adafruit_NeoMatrix.h> #include <Adafruit_NeoPixel.h> // Definimos patilla de salida de datos #define PIN 3 //Creamos el objeto matriz Adafruit_NeoMatrix matriz = Adafruit_NeoMatrix(32, 8, PIN, NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); void setup() { matriz.begin(); // Iniciamos el objeto matriz.setBrightness(15); // Establece el brillo en un 15% } void loop(){ matriz.fillScreen(0); //Apaga todos los LEDs matriz.setTextSize(1); // 1 == 8 pixeles matriz.setCursor(1, 0); // Coloca el cursor en la posici\u00f3n 4,0 en este caso concreto matriz.setTextColor(matriz.Color(255,0,0)); matriz.print('-'); matriz.setTextColor(matriz.Color(255,127,0)); matriz.print('R'); matriz.setTextColor(matriz.Color(255,255,0)); matriz.print('G'); matriz.setTextColor(matriz.Color(127,255,0)); matriz.print('B'); matriz.setTextColor(matriz.Color(0,127,0)); matriz.print('-'); matriz.show(); delay(2000); matriz.fillScreen(0); //Apaga todos los LEDs matriz.setCursor(4, 0); // Coloca el cursor en la posici\u00f3n 4,0 en este caso concreto matriz.setTextColor(matriz.Color(0,255,255)); matriz.print('3'); matriz.setTextColor(matriz.Color(0,127,255)); matriz.print('2'); matriz.setTextColor(matriz.Color(127,0,255)); matriz.print('x'); matriz.setTextColor(matriz.Color(127,0,127)); matriz.print('8'); matriz.show(); delay(2000); matriz.fillScreen(0); //Apaga todos los LEDs matriz.setCursor(2, 0); // Coloca el cursor en la posici\u00f3n 4,0 en este caso concreto matriz.setTextColor(matriz.Color(255,0,255)); matriz.print('P'); matriz.print('i'); matriz.print('x'); matriz.print('e'); matriz.print('l'); matriz.show(); delay(2000); }","title":"Textos"},{"location":"temas/matriz8x32/#uso-de-memoria-ram","text":"La librer\u00eda NeoMatrix no consume m\u00e1s memoria que NeoPixel, ya que requiere 3 bytes de RAM por cada p\u00edxel. Ahora bien, la cantidad de p\u00edxeles en una pantalla bidimensional aumenta exponencialmente, como vemos haciendo unos c\u00e1lculos sencillos: Pantalla \\space de \\space 8x8 \\space = \\space 64 \\implies Memoria \\space = \\space 192 \\space bytes Pantalla \\space de \\space 8x8 \\space = \\space 64 \\implies Memoria \\space = \\space 192 \\space bytes Pantalla \\space de \\space 16x16 \\space = \\space 256 \\implies Memoria \\space = \\space 768 \\space bytes Pantalla \\space de \\space 16x16 \\space = \\space 256 \\implies Memoria \\space = \\space 768 \\space bytes 64 \\times 4 \\space = \\space 256 \\space y \\space 192 \\times 4 \\space = 768 64 \\times 4 \\space = \\space 256 \\space y \\space 192 \\times 4 \\space = 768 Es decir, que una pantalla de 16x16 requiere cuatro veces mas memoria que una pantalla de 8x8, o aproximadamente de 768 bytes de RAM. Teniendo en cuenta que una placa UNO o nano tienen disponible una memoria SRAM de 2 kbytes, podemos decir que una matriz de 16x16 consume casi la mitad de esa memoria. Puede ser complicado o imposible combinar pantallas grandes con bibliotecas que consumen mucha memoria.","title":"Uso de memoria RAM"},{"location":"temas/matriz8x32/#correccion-gamma","text":"La respuesta a la luz del ojo humano tiene forma logar\u00edtmica, lo que significa que cuando vemos una escala de grises, nos parece que el brillo aumenta de forma continua, pero la cantidad real de luz aumenta de forma exponencial, y ese exponente es lo que se conoce como Gamma . Como referencia, un valor de gamma habitual es 2,4, es decir que cada valor tiene 2,4 veces la cantidad de luz del valor anterior. Este comportamiento exponencial ocurr\u00eda en aparatos con tubos de vacio. Actualmente se utilizan; en monitores LCD, plasma u OLED, sensores de estado s\u00f3lido, y estos tienen una respuesta lineal o muy aproximada. Esto nos da pie a pensar que Gamma es algo que est\u00e1 obsoleto, pero nada mas lejos de la realidad, ya que est\u00e1 totalmente de actualidad debido a que es un m\u00e9todo de compresi\u00f3n muy eficaz, con el que nos aseguramos que s\u00f3lo se asignan, se guardan y se transmiten valores (y diferencias de valores) que son visibles por el ojo humano, y que no se usan bits para codificar incrementos de brillo que el ojo no va a percibir. Podemos encontrar mucha mas informaci\u00f3n sobre \u00bfQu\u00e9 es gamma? en el enlace. La librer\u00eda GFX se dise\u00f1\u00f3 originalmente para pantallas LCD (con una fidelidad de color limitada), manejando los colores como valores de 16 bits (en lugar de los 24 bits completos de los que son capaces los NeoPixels). Esta no es la gran p\u00e9rdida que podr\u00eda parecer. Una peculiaridad de la visi\u00f3n humana hace que los colores brillantes sean menos perceptibles que los tenues. La biblioteca NeoMatrix utiliza la correcci\u00f3n gamma para seleccionar niveles de brillo que son visualmente (aunque no num\u00e9ricamente) equidistantes. Hay 32 niveles para rojo y azul, 64 niveles para verde. La funci\u00f3n Color() realiza la conversi\u00f3n necesaria; no necesitas hacer ning\u00fan c\u00e1lculo. Acepta valores de rojo, verde y azul de 8 bits y devuelve un color de 16 bits con correcci\u00f3n gamma que luego se puede pasar a otras funciones de dibujo.","title":"Correcci\u00f3n gamma"},{"location":"temas/matriz8x8/","text":"","title":"Matriz WS2812 8x8"},{"location":"temas/serpiente/","text":"Programa para el IDE \u00b6 Se trata de una adaptaci\u00f3n a placa nano del proyecto Snake LED 16x16 matrix game (juego arcade de la serpiente) extraido del hub de proyectos de Arduino . Los materiales para su construcci\u00f3n son: Placa tipo nano Joystick gen\u00e9rico Matriz de LEDs direccionables de 16x16 Cables para conectar los diferentes elementos El conexionado de elementos se ha realizado soldando directamente los cables en los pines de las partes y as\u00ed evitar que se suelten. El esquema b\u00e1sico de montaje es el de la figura siguiente: Esquema de conexiones El c\u00f3digo del programa serpiente , a falta de depurar, es el siguiente: #include <FastLED.h> // matriz #define NUM_LEDS 256 #define DATA_PIN 5 #define Brillo 20 //joystick #define pin_ejeX A2 // eje X #define pin_ejeY A1 // eje Y #define Pin_pulsador 2 // Pulsador // variables int snake[NUM_LEDS]; // Elementos de la matriz int longitud = 2; // Tama\u00f1o inicial de la serpiente int velocidad = 500; // Velocidad de la serpiente int fila; // fila int col; // columna int dir = 135, nueva_dir; // direcciones int i; int PosX = 1, PosY; // posiciones int f; // pixel objetivo int rojo, verde, azul, rojo_oscuro, verde_oscuro, azul_oscuro; //colores CRGB leds[NUM_LEDS]; void setup(){ rojo = random(0, 255); verde = random(0, 255); azul = random(0, 255); rojo_oscuro = random(127, 255); verde_oscuro = random(127, 255); azul_oscuro = random(127, 255); pinMode(pin_ejeX, INPUT); pinMode(pin_ejeY, INPUT); pinMode(Pin_pulsador, INPUT); digitalWrite(Pin_pulsador, HIGH); FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); FastLED.setBrightness(Brillo); for( i=0; i<=255; i++ ){ snake[i] = 0; } for( i=0; i<=longitud; i++ ){ snake[i] = dir+i; } f = random(0, 255); FastLED.show(); } int Snakedirection(int ultima, int dX, int dY){ dX = map(dX, 0, 1000, -1, 1); dY = map(dY, 0, 1000, -1, 1); if(dX == 0 && dY == 0 && PosX != dX){ dX = PosX; } if(dY == 0 && dX == 0 && PosY != dY){ dY = PosY; } int nueva_dir = ultima; if(dX != 0 ){ // movimiento eje X if (fila&1 ){ if(col == 0 && dX == 1){ nueva_dir = ultima -15;} else if(col == 15 && dX == -1){ nueva_dir = ultima +15;} else nueva_dir = ultima + dX; } else { if( col == 0 && dX == 1){ nueva_dir = ultima +15; } else if( col == 15 && dX == -1 ){ nueva_dir = ultima -15; } else nueva_dir = ultima - dX; } } if( dY > 0){ // movimiento hacia abajo eje Y if(fila == 15 && dY == -1){nueva_dir = col;} else if ( fila&1 ){nueva_dir = ultima + (col*2)+1;} else {nueva_dir = ultima + (16-col-1)+(16-col);} } if( dY < 0){ // movimiento hacia arriba eje Y if( fila == 0 && dY == 1){nueva_dir = 255 - col;} else if (fila&1 ){nueva_dir = ultima - (ultima - 16*fila) - (16 - col);} else {nueva_dir = ultima - (col*2)-1;} } PosX = dX; PosY = dY; return nueva_dir; } int snakeMove(int snakeDirection){ for(i=0; i<=255; i++ ){ if( snake[i] == snakeDirection ){ death(); } } FastLED.clear(); for(i=longitud; i>=1; i--){ snake[i] = snake[i-1]; } snake[0] = snakeDirection; for( i=0; i<=255; i++){ if( snake[i]){ leds[snake[i]].setRGB(rojo, verde, azul); } } FastLED.show(); fila = (int)(snakeDirection/16); // fila if (fila&1 ){ col = (fila+1) * 16 - snakeDirection - 1; } else { col = snakeDirection - fila * 16; } return snakeDirection; } void food(int comido ){ if(comido == f){ longitud++; f = random(0,255); rojo = rojo_oscuro; verde = verde_oscuro; azul = azul_oscuro; rojo_oscuro = random(0, 255); verde_oscuro = random(0, 255); azul_oscuro = random(0, 255); velocidad = velocidad/1.1; } else { leds[f].setRGB(rojo_oscuro, verde_oscuro, azul_oscuro); FastLED.show(); } } void death(){ longitud = 2; velocidad = 500; rojo = 255; verde = 0; azul = 0; } void color(boolean sw){ if(!sw){ rojo = random(0,255); verde = random(0,255); azul = random(0,255); } } void loop() { color(digitalRead(Pin_pulsador)); nueva_dir = Snakedirection(dir, analogRead(pin_ejeX), analogRead(pin_ejeY)); dir = snakeMove(nueva_dir); food(nueva_dir); delay(velocidad); }","title":"Programa"},{"location":"temas/serpiente/#programa-para-el-ide","text":"Se trata de una adaptaci\u00f3n a placa nano del proyecto Snake LED 16x16 matrix game (juego arcade de la serpiente) extraido del hub de proyectos de Arduino . Los materiales para su construcci\u00f3n son: Placa tipo nano Joystick gen\u00e9rico Matriz de LEDs direccionables de 16x16 Cables para conectar los diferentes elementos El conexionado de elementos se ha realizado soldando directamente los cables en los pines de las partes y as\u00ed evitar que se suelten. El esquema b\u00e1sico de montaje es el de la figura siguiente: Esquema de conexiones El c\u00f3digo del programa serpiente , a falta de depurar, es el siguiente: #include <FastLED.h> // matriz #define NUM_LEDS 256 #define DATA_PIN 5 #define Brillo 20 //joystick #define pin_ejeX A2 // eje X #define pin_ejeY A1 // eje Y #define Pin_pulsador 2 // Pulsador // variables int snake[NUM_LEDS]; // Elementos de la matriz int longitud = 2; // Tama\u00f1o inicial de la serpiente int velocidad = 500; // Velocidad de la serpiente int fila; // fila int col; // columna int dir = 135, nueva_dir; // direcciones int i; int PosX = 1, PosY; // posiciones int f; // pixel objetivo int rojo, verde, azul, rojo_oscuro, verde_oscuro, azul_oscuro; //colores CRGB leds[NUM_LEDS]; void setup(){ rojo = random(0, 255); verde = random(0, 255); azul = random(0, 255); rojo_oscuro = random(127, 255); verde_oscuro = random(127, 255); azul_oscuro = random(127, 255); pinMode(pin_ejeX, INPUT); pinMode(pin_ejeY, INPUT); pinMode(Pin_pulsador, INPUT); digitalWrite(Pin_pulsador, HIGH); FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS); FastLED.setBrightness(Brillo); for( i=0; i<=255; i++ ){ snake[i] = 0; } for( i=0; i<=longitud; i++ ){ snake[i] = dir+i; } f = random(0, 255); FastLED.show(); } int Snakedirection(int ultima, int dX, int dY){ dX = map(dX, 0, 1000, -1, 1); dY = map(dY, 0, 1000, -1, 1); if(dX == 0 && dY == 0 && PosX != dX){ dX = PosX; } if(dY == 0 && dX == 0 && PosY != dY){ dY = PosY; } int nueva_dir = ultima; if(dX != 0 ){ // movimiento eje X if (fila&1 ){ if(col == 0 && dX == 1){ nueva_dir = ultima -15;} else if(col == 15 && dX == -1){ nueva_dir = ultima +15;} else nueva_dir = ultima + dX; } else { if( col == 0 && dX == 1){ nueva_dir = ultima +15; } else if( col == 15 && dX == -1 ){ nueva_dir = ultima -15; } else nueva_dir = ultima - dX; } } if( dY > 0){ // movimiento hacia abajo eje Y if(fila == 15 && dY == -1){nueva_dir = col;} else if ( fila&1 ){nueva_dir = ultima + (col*2)+1;} else {nueva_dir = ultima + (16-col-1)+(16-col);} } if( dY < 0){ // movimiento hacia arriba eje Y if( fila == 0 && dY == 1){nueva_dir = 255 - col;} else if (fila&1 ){nueva_dir = ultima - (ultima - 16*fila) - (16 - col);} else {nueva_dir = ultima - (col*2)-1;} } PosX = dX; PosY = dY; return nueva_dir; } int snakeMove(int snakeDirection){ for(i=0; i<=255; i++ ){ if( snake[i] == snakeDirection ){ death(); } } FastLED.clear(); for(i=longitud; i>=1; i--){ snake[i] = snake[i-1]; } snake[0] = snakeDirection; for( i=0; i<=255; i++){ if( snake[i]){ leds[snake[i]].setRGB(rojo, verde, azul); } } FastLED.show(); fila = (int)(snakeDirection/16); // fila if (fila&1 ){ col = (fila+1) * 16 - snakeDirection - 1; } else { col = snakeDirection - fila * 16; } return snakeDirection; } void food(int comido ){ if(comido == f){ longitud++; f = random(0,255); rojo = rojo_oscuro; verde = verde_oscuro; azul = azul_oscuro; rojo_oscuro = random(0, 255); verde_oscuro = random(0, 255); azul_oscuro = random(0, 255); velocidad = velocidad/1.1; } else { leds[f].setRGB(rojo_oscuro, verde_oscuro, azul_oscuro); FastLED.show(); } } void death(){ longitud = 2; velocidad = 500; rojo = 255; verde = 0; azul = 0; } void color(boolean sw){ if(!sw){ rojo = random(0,255); verde = random(0,255); azul = random(0,255); } } void loop() { color(digitalRead(Pin_pulsador)); nueva_dir = Snakedirection(dir, analogRead(pin_ejeX), analogRead(pin_ejeY)); dir = snakeMove(nueva_dir); food(nueva_dir); delay(velocidad); }","title":"Programa para el IDE"},{"location":"temas/softAB/","text":"ArduinoBlocks \u00b6 Principalmente vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5.1 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5.1 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"ArduinoBlocks"},{"location":"temas/softAB/#arduinoblocks","text":"Principalmente vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5.1 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5.1 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"ArduinoBlocks"},{"location":"temas/softIDE/","text":"IDE 2 de Arduino \u00b6 Casi con toda seguridad que se nos va a presentar alguna ocasi\u00f3n en que ArduinoBlocks no satisfaga nuestras necesidades porque no exista el bloque en el momento que lo necesitamos. En estas ocasiones no nos va a quedar mas remedio que recurrir al Entorno de Desarrollo Integrado o IDE de Arduino. Antes de continuar indicar que aqu\u00ed vamos a describir como llevar a cabo los primeros pasos con el IDE 2.0 pero no vamos a tratar conceptos de programaci\u00f3n mediante c\u00f3digo. Vamos a describir como trabajar con el Arduino IDE 2.0 que ofrece mayor rendimiento, una interfaz de usuario mejorada y caracter\u00edsticas nuevas, como el autocompletado , un depurador incorporado y la sincronizaci\u00f3n de bocetos con Arduino Cloud. Todos los tutoriales del Arduino IDE 2 los tenemos en el enlace. C\u00f3digo en ArduinoBlocks \u00b6 La plataforma visual tambi\u00e9n nos ofrece algunas opciones para disponer del c\u00f3digo del programa y de las librer\u00edas que se utilizan, opciones que nos pueden resultar de utilidad en especial si no disponemos de bloques para continuar con nuestro programa. En la animaci\u00f3n de la figura siguiente vemos como ArduinoBlocks nos permite diferentes opciones de trabajo con el IDE, que son: Ver c\u00f3digo . Se despliega una ventana con el c\u00f3digo del programa actual cargado. Descargar c\u00f3digo (.ino) . Para exportar el c\u00f3digo para utilizarlo en Arduino IDE. ZIP project (.zip) . Para exportar el proyecto completo como .zip incluyendo librer\u00edas para Arduino IDE. Opciones de exportaci\u00f3n de ArduinoBlocks En el enlace a librer\u00edas podemos descargar el paquete que utiliza ArduinoBlocks e instalarlas todas o la que nos interese en el directorio de librer\u00edas de Arduino. Estas librer\u00edas nos ofrecen una ventaja adicional, y es que son librer\u00edas probadas y que funcionan correctamente. Descarga \u00b6 Podemos descargarlo desde la p\u00e1gina de software de Arduino IDE 2.0 y en el momento de creaci\u00f3n de este apartado de la web nos ofrece la versi\u00f3n 2.0.2 adem\u00e1s de los enlaces al editor online, tal y como vemos en la figura siguiente. Descargas En esta p\u00e1gina tenemos disponibles las versiones Nightly y otras informaciones importantes como: La versi\u00f3n de escritorio no est\u00e1 disponible para Chromebook donde deberemos trabajar con el editor web de Arduino . Es posible programar las placas utilizando MicroPython. En la p\u00e1gina MicroPython with Arduino tenemos toda la informaci\u00f3n. Opciones de descarga de versiones anteriores del IDE. T\u00e9rminos de servicio Si tenemos alguna duda podemos seguir el tutorial en ingl\u00e9s de descarga e instalaci\u00f3n de Arduino IDE 2.0 . Ventana principal del IDE 2.0 \u00b6 En la figura siguiente vemos el aspecto que presenta el IDE en la versi\u00f3n 2.0. Arduino IDE 2.0 A continuaci\u00f3n se describen de forma r\u00e1pida los apartados se\u00f1alados en la figura anterior. Verify/Upload (Verificar/Cargar): Para compilar y cargar el c\u00f3digo en la placa. Select board & port (Seleccionar placa y puerto): En el desplegable se muestran las placas detectadas de forma autom\u00e1tica, junto con el puerto asignado. Open Serial Plotter (abrir trazador ser\u00ede): Abre la herramienta de graficado como una nueva ventana. Open Serial Monitor (abrir el monitor serie): abre la herramienta Serial Monitor, como una nueva pesta\u00f1a en la consola. Sketchbook (Carpeta de programas): es el directorio o carpeta donde se almacenan localmente los programas. Adem\u00e1s, desde aqu\u00ed se puede sincronizar con Arduino Cloud y tambi\u00e9n obtener los sketch del entorno online. Boards Manager (Administrador de placas): para explorar los paquetes de Arduino y de terceros que se pueden instalar. Por ejemplo, usar una placa MKR WiFi 1010 requiere tener instalado el paquete Arduino SAMD Boards . Library Manager (Ad https://docs.arduino.cc/software/ide-v2./img/teo-basica/soft/ministrador de librer\u00edas): Para navegar por las librer\u00edas propias de Arduino y las creadas por la comunidad. Debugger (Depurador): Para probar y depurar programas en tiempo real. Search (Buscar): b\u00fasqueda de palabras en el c\u00f3digo. Caracter\u00edsticas principales del IDE 2.0 \u00b6 Ajustar preferencias \u00b6 En la animaci\u00f3n de la figura siguiente vemos como acceder a la configuraci\u00f3n de las mismas y tambi\u00e9n como se realiza alg\u00fan ajuste adicional. Preferencias IDE 2.0 La carpeta de programas \u00b6 Los programas o sketches de Arduino se guardan como .ino y deben almacenarse en una carpeta con el mismo nombre. Por ejemplo, un programa de nombre 'mi_programa.ino' debe almacenarse en una carpeta llamada 'mi_programa'. Generalmente se guardan en una carpeta de nombre 'Arduino' en la carpeta personal. En la animaci\u00f3n siguiente vemos como abrir y cerrar esta carpeta desde el bot\u00f3n de la barra lateral y como nos muestra el contenido Carpeta de programas Administrador de placas \u00b6 Con el Administrador de placas se pueden buscar e instalar paquetes o \"n\u00facleos\" para nuestras placas. Compilar y cargar un programa en una placa siempre requiere un paquete de la placa. Hay muchos paquetes de placa Arduino disponibles, como avr, samd, megaav y muchos m\u00e1s. basica Podemos decir que un \"n\u00facleo\" est\u00e1 escrito y dise\u00f1ado para microcontroladores espec\u00edficos y sabemos que las diferentes placas tienen micros de diferentes tipos. Por ejemplo, un Arduino UNO tiene un ATmega328P , que usa el n\u00facleo AVR , mientras que un Arduino Nano 33 IoT tiene un microcontrolador SAMD21 , donde necesitamos usar el n\u00facleo SAMD . En definitiva, para poder usar una placa concreta debemos instalar su n\u00facleo espec\u00edfico. Al hacer clic en el bot\u00f3n de la barra lateral se nos abren todas las opciones disponibles y ne indica si est\u00e1n o no instalados y adem\u00e1s dispone de un buscador que permite localizar el n\u00facleo que necesitamos. Hay que tener presente que la instalaci\u00f3n de algunos de ellos puede tardar varios minutos. En la animaci\u00f3n vemos el funcionamiento de este bot\u00f3n. Administrador de placas Gestor de librer\u00edas \u00b6 Este bot\u00f3n nos permite buscar e instalar librer\u00edas, que son extensiones de la API de Arduino que facilitan el control de un servo, leer un sensor espec\u00edfico o utilizar un m\u00f3dulo WiFi. En la animaci\u00f3n vemos como utilizar este bot\u00f3n. Gestor de librer\u00edas Monitor serie \u00b6 Esta herramienta que habitualmente estaba en una ventana separada ahora se integra en el editor. La herramienta sirve para comunicarse con la placa o para depurar programas. Una ventaja de tener el Serial Monitor integrado con el editor es la posibilidad de tener m\u00faltiples monitores abiertos simult\u00e1neamente. En el editor antiguo, al cambiar el puerto/placa, cambiaba en todas las ventanas. Adem\u00e1s, est\u00e1bamos limitados a una ventana de Serial Monitor, un obst\u00e1culo que el IDE 2.0 elimina. En la animaci\u00f3n vemos el uso b\u00e1sico del mismo. Monitor serie basica Para obtener m\u00e1s informaci\u00f3n sobre Serial Monitor podemos visitar el Serial Monitor tutorial . Serial Plotter \u00b6 Nos permite visualizar datos utilizando gr\u00e1ficos permitiendo monitorizar varias variables de manera simultanea. Para ver mejor el funcionamiento de este elemento vamos a utilizar el potenci\u00f3metro de la autocaravana (A3) junto con una variable est\u00e1tica y una aleatoria. El c\u00f3digo del ejemplo es: int potenciometro; int aleatoria; int static_variable = 500; void setup() { Serial.begin(9600); } void loop() { potenciometro = analogRead(A3); aleatoria = random(0, 1000); Serial.print(\"Potenciometro:\"); Serial.print(potenciometro); Serial.print(\",\"); Serial.print(\"Vlor aleatorio:\"); Serial.print(aleatoria); Serial.print(\",\"); Serial.print(\"Variable estatica:\"); Serial.println(static_variable); } En la animaci\u00f3n vemos como cargar el programa y el funcionamiento en la ventana del Serial Plotter. Serial Plotter Debugger \u00b6 El depurador se utiliza para probar y depurar programas. B\u00e1sicamente lo que permite es navegar a trav\u00e9s de la ejecuci\u00f3n de un programa, lo que sirve para detectar fallos o errores de c\u00f3digo. El depurador solamente est\u00e1 disponible con las placas SAMD. Tenemos mas informaci\u00f3n en Debugging tutorial . Autocompletado \u00b6 Es una nueva caracter\u00edstica de la versi\u00f3n 2.0 muy bien equipada. Debemos tener presente que para que funcione debemos tener seleccionada la placa a utilizar. En la animaci\u00f3n siguiente vemos la herramienta funcionando. Autocompletado","title":"IDE 2"},{"location":"temas/softIDE/#ide-2-de-arduino","text":"Casi con toda seguridad que se nos va a presentar alguna ocasi\u00f3n en que ArduinoBlocks no satisfaga nuestras necesidades porque no exista el bloque en el momento que lo necesitamos. En estas ocasiones no nos va a quedar mas remedio que recurrir al Entorno de Desarrollo Integrado o IDE de Arduino. Antes de continuar indicar que aqu\u00ed vamos a describir como llevar a cabo los primeros pasos con el IDE 2.0 pero no vamos a tratar conceptos de programaci\u00f3n mediante c\u00f3digo. Vamos a describir como trabajar con el Arduino IDE 2.0 que ofrece mayor rendimiento, una interfaz de usuario mejorada y caracter\u00edsticas nuevas, como el autocompletado , un depurador incorporado y la sincronizaci\u00f3n de bocetos con Arduino Cloud. Todos los tutoriales del Arduino IDE 2 los tenemos en el enlace.","title":"IDE 2 de Arduino"},{"location":"temas/softIDE/#codigo-en-arduinoblocks","text":"La plataforma visual tambi\u00e9n nos ofrece algunas opciones para disponer del c\u00f3digo del programa y de las librer\u00edas que se utilizan, opciones que nos pueden resultar de utilidad en especial si no disponemos de bloques para continuar con nuestro programa. En la animaci\u00f3n de la figura siguiente vemos como ArduinoBlocks nos permite diferentes opciones de trabajo con el IDE, que son: Ver c\u00f3digo . Se despliega una ventana con el c\u00f3digo del programa actual cargado. Descargar c\u00f3digo (.ino) . Para exportar el c\u00f3digo para utilizarlo en Arduino IDE. ZIP project (.zip) . Para exportar el proyecto completo como .zip incluyendo librer\u00edas para Arduino IDE. Opciones de exportaci\u00f3n de ArduinoBlocks En el enlace a librer\u00edas podemos descargar el paquete que utiliza ArduinoBlocks e instalarlas todas o la que nos interese en el directorio de librer\u00edas de Arduino. Estas librer\u00edas nos ofrecen una ventaja adicional, y es que son librer\u00edas probadas y que funcionan correctamente.","title":"C\u00f3digo en ArduinoBlocks"},{"location":"temas/softIDE/#descarga","text":"Podemos descargarlo desde la p\u00e1gina de software de Arduino IDE 2.0 y en el momento de creaci\u00f3n de este apartado de la web nos ofrece la versi\u00f3n 2.0.2 adem\u00e1s de los enlaces al editor online, tal y como vemos en la figura siguiente. Descargas En esta p\u00e1gina tenemos disponibles las versiones Nightly y otras informaciones importantes como: La versi\u00f3n de escritorio no est\u00e1 disponible para Chromebook donde deberemos trabajar con el editor web de Arduino . Es posible programar las placas utilizando MicroPython. En la p\u00e1gina MicroPython with Arduino tenemos toda la informaci\u00f3n. Opciones de descarga de versiones anteriores del IDE. T\u00e9rminos de servicio Si tenemos alguna duda podemos seguir el tutorial en ingl\u00e9s de descarga e instalaci\u00f3n de Arduino IDE 2.0 .","title":"Descarga"},{"location":"temas/softIDE/#ventana-principal-del-ide-20","text":"En la figura siguiente vemos el aspecto que presenta el IDE en la versi\u00f3n 2.0. Arduino IDE 2.0 A continuaci\u00f3n se describen de forma r\u00e1pida los apartados se\u00f1alados en la figura anterior. Verify/Upload (Verificar/Cargar): Para compilar y cargar el c\u00f3digo en la placa. Select board & port (Seleccionar placa y puerto): En el desplegable se muestran las placas detectadas de forma autom\u00e1tica, junto con el puerto asignado. Open Serial Plotter (abrir trazador ser\u00ede): Abre la herramienta de graficado como una nueva ventana. Open Serial Monitor (abrir el monitor serie): abre la herramienta Serial Monitor, como una nueva pesta\u00f1a en la consola. Sketchbook (Carpeta de programas): es el directorio o carpeta donde se almacenan localmente los programas. Adem\u00e1s, desde aqu\u00ed se puede sincronizar con Arduino Cloud y tambi\u00e9n obtener los sketch del entorno online. Boards Manager (Administrador de placas): para explorar los paquetes de Arduino y de terceros que se pueden instalar. Por ejemplo, usar una placa MKR WiFi 1010 requiere tener instalado el paquete Arduino SAMD Boards . Library Manager (Ad https://docs.arduino.cc/software/ide-v2./img/teo-basica/soft/ministrador de librer\u00edas): Para navegar por las librer\u00edas propias de Arduino y las creadas por la comunidad. Debugger (Depurador): Para probar y depurar programas en tiempo real. Search (Buscar): b\u00fasqueda de palabras en el c\u00f3digo.","title":"Ventana principal del IDE 2.0"},{"location":"temas/softIDE/#caracteristicas-principales-del-ide-20","text":"","title":"Caracter\u00edsticas principales del IDE 2.0"},{"location":"temas/softIDE/#ajustar-preferencias","text":"En la animaci\u00f3n de la figura siguiente vemos como acceder a la configuraci\u00f3n de las mismas y tambi\u00e9n como se realiza alg\u00fan ajuste adicional. Preferencias IDE 2.0","title":"Ajustar preferencias"},{"location":"temas/softIDE/#la-carpeta-de-programas","text":"Los programas o sketches de Arduino se guardan como .ino y deben almacenarse en una carpeta con el mismo nombre. Por ejemplo, un programa de nombre 'mi_programa.ino' debe almacenarse en una carpeta llamada 'mi_programa'. Generalmente se guardan en una carpeta de nombre 'Arduino' en la carpeta personal. En la animaci\u00f3n siguiente vemos como abrir y cerrar esta carpeta desde el bot\u00f3n de la barra lateral y como nos muestra el contenido Carpeta de programas","title":"La carpeta de programas"},{"location":"temas/softIDE/#administrador-de-placas","text":"Con el Administrador de placas se pueden buscar e instalar paquetes o \"n\u00facleos\" para nuestras placas. Compilar y cargar un programa en una placa siempre requiere un paquete de la placa. Hay muchos paquetes de placa Arduino disponibles, como avr, samd, megaav y muchos m\u00e1s. basica Podemos decir que un \"n\u00facleo\" est\u00e1 escrito y dise\u00f1ado para microcontroladores espec\u00edficos y sabemos que las diferentes placas tienen micros de diferentes tipos. Por ejemplo, un Arduino UNO tiene un ATmega328P , que usa el n\u00facleo AVR , mientras que un Arduino Nano 33 IoT tiene un microcontrolador SAMD21 , donde necesitamos usar el n\u00facleo SAMD . En definitiva, para poder usar una placa concreta debemos instalar su n\u00facleo espec\u00edfico. Al hacer clic en el bot\u00f3n de la barra lateral se nos abren todas las opciones disponibles y ne indica si est\u00e1n o no instalados y adem\u00e1s dispone de un buscador que permite localizar el n\u00facleo que necesitamos. Hay que tener presente que la instalaci\u00f3n de algunos de ellos puede tardar varios minutos. En la animaci\u00f3n vemos el funcionamiento de este bot\u00f3n. Administrador de placas","title":"Administrador de placas"},{"location":"temas/softIDE/#gestor-de-librerias","text":"Este bot\u00f3n nos permite buscar e instalar librer\u00edas, que son extensiones de la API de Arduino que facilitan el control de un servo, leer un sensor espec\u00edfico o utilizar un m\u00f3dulo WiFi. En la animaci\u00f3n vemos como utilizar este bot\u00f3n. Gestor de librer\u00edas","title":"Gestor de librer\u00edas"},{"location":"temas/softIDE/#monitor-serie","text":"Esta herramienta que habitualmente estaba en una ventana separada ahora se integra en el editor. La herramienta sirve para comunicarse con la placa o para depurar programas. Una ventaja de tener el Serial Monitor integrado con el editor es la posibilidad de tener m\u00faltiples monitores abiertos simult\u00e1neamente. En el editor antiguo, al cambiar el puerto/placa, cambiaba en todas las ventanas. Adem\u00e1s, est\u00e1bamos limitados a una ventana de Serial Monitor, un obst\u00e1culo que el IDE 2.0 elimina. En la animaci\u00f3n vemos el uso b\u00e1sico del mismo. Monitor serie basica Para obtener m\u00e1s informaci\u00f3n sobre Serial Monitor podemos visitar el Serial Monitor tutorial .","title":"Monitor serie"},{"location":"temas/softIDE/#serial-plotter","text":"Nos permite visualizar datos utilizando gr\u00e1ficos permitiendo monitorizar varias variables de manera simultanea. Para ver mejor el funcionamiento de este elemento vamos a utilizar el potenci\u00f3metro de la autocaravana (A3) junto con una variable est\u00e1tica y una aleatoria. El c\u00f3digo del ejemplo es: int potenciometro; int aleatoria; int static_variable = 500; void setup() { Serial.begin(9600); } void loop() { potenciometro = analogRead(A3); aleatoria = random(0, 1000); Serial.print(\"Potenciometro:\"); Serial.print(potenciometro); Serial.print(\",\"); Serial.print(\"Vlor aleatorio:\"); Serial.print(aleatoria); Serial.print(\",\"); Serial.print(\"Variable estatica:\"); Serial.println(static_variable); } En la animaci\u00f3n vemos como cargar el programa y el funcionamiento en la ventana del Serial Plotter. Serial Plotter","title":"Serial Plotter"},{"location":"temas/softIDE/#debugger","text":"El depurador se utiliza para probar y depurar programas. B\u00e1sicamente lo que permite es navegar a trav\u00e9s de la ejecuci\u00f3n de un programa, lo que sirve para detectar fallos o errores de c\u00f3digo. El depurador solamente est\u00e1 disponible con las placas SAMD. Tenemos mas informaci\u00f3n en Debugging tutorial .","title":"Debugger"},{"location":"temas/softIDE/#autocompletado","text":"Es una nueva caracter\u00edstica de la versi\u00f3n 2.0 muy bien equipada. Debemos tener presente que para que funcione debemos tener seleccionada la placa a utilizar. En la animaci\u00f3n siguiente vemos la herramienta funcionando. Autocompletado","title":"Autocompletado"}]}